<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.7.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>
<meta name="description" content="I2C通信I2C协议I2C协议运用已经非常广泛，直接看图，一图胜前言。  I2C设备驱动数据处理 Linux内核代码：drivers\i2c\i2c-core.c  数据处理函数: 12345678910111213&#x2F;** * i2c_transfer - execute a single or combined I2C message * @adap: Handle to I2C bus * @">
<meta property="og:type" content="article">
<meta property="og:title" content="I2C子系统">
<meta property="og:url" content="http://example.com/2021/09/12/Linux%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Huahui">
<meta property="og:description" content="I2C通信I2C协议I2C协议运用已经非常广泛，直接看图，一图胜前言。  I2C设备驱动数据处理 Linux内核代码：drivers\i2c\i2c-core.c  数据处理函数: 12345678910111213&#x2F;** * i2c_transfer - execute a single or combined I2C message * @adap: Handle to I2C bus * @">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2021/09/12/Linux%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/NO1.png">
<meta property="og:image" content="http://example.com/2021/09/12/Linux%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/NO2.png">
<meta property="og:image" content="http://example.com/2021/09/12/Linux%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/NO3.png">
<meta property="og:image" content="http://example.com/2021/09/12/Linux%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/04_smbus_receive_byte.png">
<meta property="og:image" content="http://example.com/2021/09/12/Linux%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/05_smbus_send_byte.png">
<meta property="og:image" content="http://example.com/2021/09/12/Linux%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/06_smbus_read_byte.png">
<meta property="og:image" content="http://example.com/2021/09/12/Linux%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/07_smbus_read_word.png">
<meta property="og:image" content="http://example.com/2021/09/12/Linux%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/08_smbus_write_byte.png">
<meta property="og:image" content="http://example.com/2021/09/12/Linux%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/09_smbus_write_word.png">
<meta property="article:published_time" content="2021-09-12T10:42:44.000Z">
<meta property="article:modified_time" content="2021-09-12T10:54:14.108Z">
<meta property="article:author" content="huahui">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="driver">
<meta property="article:tag" content="I2C">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/09/12/Linux%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/NO1.png">


<link rel="canonical" href="http://example.com/2021/09/12/Linux%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2021/09/12/Linux%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/","path":"2021/09/12/Linux驱动-I2C子系统/","title":"I2C子系统"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>I2C子系统 | Huahui</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Huahui</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#I2C%E9%80%9A%E4%BF%A1"><span class="nav-number">1.</span> <span class="nav-text">I2C通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#I2C%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.1.</span> <span class="nav-text">I2C协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I2C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="nav-number">1.2.</span> <span class="nav-text">I2C设备驱动数据处理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#kernel%E4%B8%ADi2c%E9%A9%B1%E5%8A%A8"><span class="nav-number">2.</span> <span class="nav-text">kernel中i2c驱动</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83-i2c-driver-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">2.1.</span> <span class="nav-text">核心  i2c_driver 结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#i2c-driver%E8%A1%A8%E6%98%8E%E8%83%BD%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E8%AE%BE%E5%A4%87"><span class="nav-number">2.2.</span> <span class="nav-text">i2c_driver表明能支持哪些设备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#i2c-client"><span class="nav-number">2.3.</span> <span class="nav-text">i2c_client</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SMBus%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.</span> <span class="nav-text">SMBus协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SMBus%E6%98%AFI2C%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AD%90%E9%9B%86%E3%80%82"><span class="nav-number">3.1.</span> <span class="nav-text">SMBus是I2C协议的一个子集。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SMBus%E4%B8%8E%E4%B8%80%E8%88%ACI2C%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%AE%E5%88%AB"><span class="nav-number">3.2.</span> <span class="nav-text">SMBus与一般I2C协议的差别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SMBus%E9%80%9A%E4%BF%A1"><span class="nav-number">3.3.</span> <span class="nav-text">SMBus通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Receive-Byte"><span class="nav-number">3.3.1.</span> <span class="nav-text">Receive Byte</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Send-Byte"><span class="nav-number">3.3.2.</span> <span class="nav-text">Send Byte</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Read-Byte"><span class="nav-number">3.3.3.</span> <span class="nav-text">Read Byte</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Read-Word"><span class="nav-number">3.3.4.</span> <span class="nav-text">Read Word</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Write-Byte"><span class="nav-number">3.3.5.</span> <span class="nav-text">Write Byte</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Write-Word"><span class="nav-number">3.3.6.</span> <span class="nav-text">Write Word</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">huahui</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/12/Linux%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="huahui">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huahui">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          I2C子系统
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-09-12 18:42:44 / Modified: 18:54:14" itemprop="dateCreated datePublished" datetime="2021-09-12T18:42:44+08:00">2021-09-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux%E9%A9%B1%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">Linux驱动</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="I2C通信"><a href="#I2C通信" class="headerlink" title="I2C通信"></a>I2C通信</h1><h2 id="I2C协议"><a href="#I2C协议" class="headerlink" title="I2C协议"></a>I2C协议</h2><p>I2C协议运用已经非常广泛，直接看图，一图胜前言。</p>
<p><img src="/2021/09/12/Linux%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/NO1.png" alt="image"></p>
<h2 id="I2C设备驱动数据处理"><a href="#I2C设备驱动数据处理" class="headerlink" title="I2C设备驱动数据处理"></a>I2C设备驱动数据处理</h2><ul>
<li>Linux内核代码：<code>drivers\i2c\i2c-core.c</code></li>
</ul>
<p>数据处理函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_transfer - execute a single or combined I2C message</span></span><br><span class="line"><span class="comment"> * @adap: Handle to I2C bus</span></span><br><span class="line"><span class="comment"> * @msgs: One or more messages to execute before STOP is issued to</span></span><br><span class="line"><span class="comment"> *	terminate the operation; each message begins with a START.</span></span><br><span class="line"><span class="comment"> * @num: Number of messages to be executed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns negative errno, else the number of messages executed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that there is no requirement that each message be sent to</span></span><br><span class="line"><span class="comment"> * the same slave address, although that is the most common model.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_transfer</span><span class="params">(struct i2c_adapter *adap, struct i2c_msg *msgs, <span class="keyword">int</span> num)</span></span></span><br></pre></td></tr></table></figure>

<p>使用<code>i2c_transfer</code>函数发送数据之前要先构建好<code> i2c_msg</code>  。 </p>
<p><code>i2c_msg</code> 结构体定义在文件 <code>include/uapi/linux/i2c.h </code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> &#123;</span></span><br><span class="line">	__u16 addr;	<span class="comment">/* slave address			*/</span></span><br><span class="line">	__u16 flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_RD		0x0001	<span class="comment">/* read data, from slave to master */</span></span></span><br><span class="line">					<span class="comment">/* I2C_M_RD is guaranteed to be 0x0001! */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_TEN		0x0010	<span class="comment">/* this is a ten bit chip address */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_RECV_LEN		0x0400	<span class="comment">/* length will be first received byte */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_NO_RD_ACK		0x0800	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_IGNORE_NAK	0x1000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_REV_DIR_ADDR	0x2000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_NOSTART		0x4000	<span class="comment">/* if I2C_FUNC_NOSTART */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_STOP		0x8000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line">	__u16 len;		<span class="comment">/* msg length				*/</span></span><br><span class="line">	__u8 *buf;		<span class="comment">/* pointer to msg data			*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以读取 I2C 设备寄存器数据为例：</p>
<p>(参考正点原子)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>[2];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* msg[0]，第一条写消息，发送要读取的寄存器地址 */</span></span><br><span class="line">msg[<span class="number">0</span>].addr = addr; <span class="comment">/* I2C 设备地址 */</span></span><br><span class="line">msg[<span class="number">0</span>].flags = <span class="number">0</span>; <span class="comment">/* 标记为发送数据 */</span></span><br><span class="line">msg[<span class="number">0</span>].buf = &amp;reg; <span class="comment">/* 读取的首地址 */</span></span><br><span class="line">msg[<span class="number">0</span>].len = <span class="number">1</span>; <span class="comment">/* reg 长度 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* msg[1]，第二条读消息，读取寄存器数据 */</span></span><br><span class="line">msg[<span class="number">1</span>].addr = addr; <span class="comment">/* I2C 设备地址 */</span></span><br><span class="line">msg[<span class="number">1</span>].flags = I2C_M_RD; <span class="comment">/* 标记为读取数据 */</span></span><br><span class="line">msg[<span class="number">1</span>].buf = val; <span class="comment">/* 读取数据缓冲区 */</span></span><br><span class="line">msg[<span class="number">1</span>].len = len; <span class="comment">/* 要读取的数据长度 */</span></span><br><span class="line"></span><br><span class="line">ret = i2c_transfer(adapter, msg, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>向 I2C 设备寄存器写入数据：</p>
<p>(参考正点原子)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">u8 b[<span class="number">256</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (struct i2c_client *)</span><br><span class="line">dev-&gt;private_data;</span><br><span class="line"></span><br><span class="line">b[<span class="number">0</span>] = reg; <span class="comment">/* 寄存器首地址 */</span></span><br><span class="line"><span class="built_in">memcpy</span>(&amp;b[<span class="number">1</span>],buf,len); <span class="comment">/* 将要发送的数据拷贝到数组 b 里面 */</span></span><br><span class="line"></span><br><span class="line">msg.addr = addr; <span class="comment">/* I2C 设备地址 */</span></span><br><span class="line">msg.flags = <span class="number">0</span>; <span class="comment">/* 标记为写数据 */</span></span><br><span class="line"></span><br><span class="line">msg.buf = b; <span class="comment">/* 要发送的数据缓冲区 */</span></span><br><span class="line">msg.len = len + <span class="number">1</span>;   <span class="comment">/* 实际数据长度 + 寄存器地址长度*/</span></span><br><span class="line"></span><br><span class="line">ret = i2c_transfer(client-&gt;adapter, &amp;msg, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>Linux内核对<code>i2c_transfer</code>进一步封装，形成两个API函数分别用于I2C数据的接收和发送操作  。代码位于：<code>drivers\i2c\i2c-core.c</code></p>
<ul>
<li>i2c_master_recv</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_master_recv - issue a single I2C message in master receive mode</span></span><br><span class="line"><span class="comment"> * @client: Handle to slave device</span></span><br><span class="line"><span class="comment"> * @buf: Where to store data read from slave</span></span><br><span class="line"><span class="comment"> * @count: How many bytes to read, must be less than 64k since msg.len is u16</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns negative errno, or else the number of bytes read.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_master_recv</span><span class="params">(<span class="keyword">const</span> struct i2c_client *client, <span class="keyword">char</span> *buf, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<ul>
<li>i2c_master_send</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_master_send - issue a single I2C message in master transmit mode</span></span><br><span class="line"><span class="comment"> * @client: Handle to slave device</span></span><br><span class="line"><span class="comment"> * @buf: Data that will be written to the slave</span></span><br><span class="line"><span class="comment"> * @count: How many bytes to write, must be less than 64k since msg.len is u16</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns negative errno, or else the number of bytes written.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_master_send</span><span class="params">(<span class="keyword">const</span> struct i2c_client *client, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> count)</span></span></span><br></pre></td></tr></table></figure>

<h1 id="kernel中i2c驱动"><a href="#kernel中i2c驱动" class="headerlink" title="kernel中i2c驱动"></a>kernel中i2c驱动</h1><h2 id="核心-i2c-driver-结构体"><a href="#核心-i2c-driver-结构体" class="headerlink" title="核心  i2c_driver 结构体"></a>核心  i2c_driver 结构体</h2><p>分配、设置、注册一个i2c_driver结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">i2c_example_driver</span> =</span> &#123;</span><br><span class="line">	.driver = &#123;</span><br><span class="line">		.name = <span class="string">&quot;example&quot;</span>,</span><br><span class="line">		.of_match_table = of_match_ids_example,</span><br><span class="line">	&#125;,</span><br><span class="line">	.probe = i2c_example_driver_probe,</span><br><span class="line">	.remove = i2c_example_driver_remove,</span><br><span class="line">	.id_table = example_ids,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>出入口函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*入口函数 注册一个i2c_drvier */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">i2c_driver_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i2c_add_driver(&amp;i2c_example_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(i2c_driver_init);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**出口函数 del一个i2c_drvier */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">i2c_driver_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i2c_del_driver(&amp;i2c_example_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="i2c-driver表明能支持哪些设备"><a href="#i2c-driver表明能支持哪些设备" class="headerlink" title="i2c_driver表明能支持哪些设备"></a>i2c_driver表明能支持哪些设备</h2><p>i2c_driver表明能支持哪些设备：</p>
<ul>
<li><p>使用of_match_table来判断</p>
<ul>
<li>设备树中，某个I2C控制器节点下可以创建I2C设备的节点<ul>
<li>如果I2C设备节点的compatible属性跟of_match_table的某项兼容，则匹配成功</li>
</ul>
</li>
<li>i2c_client.name跟某个of_match_table[i].compatible值相同，则匹配成功</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_match_ids_example</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;com_name,chip_name&quot;</span>,   .data = <span class="literal">NULL</span>&#125;,</span><br><span class="line">	&#123; <span class="comment">/* END OF LIST */</span> &#125;  <span class="comment">/*最后空一项为必须，空闲为end 判断条件*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// of_ 开头一般与设备树关联</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用id_table来判断</p>
<ul>
<li>i2c_client.name跟某个id_table[i].name值相同，则匹配成功</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">example_ids</span>[] =</span> &#123;</span><br><span class="line">	&#123; <span class="string">&quot;chip_name&quot;</span>,  (<span class="keyword">kernel_ulong_t</span>)<span class="literal">NULL</span> &#125;,</span><br><span class="line">	&#123; <span class="comment">/* END OF LIST */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>i2c_driver跟i2c_client匹配成功后，就调用<strong>i2c_driver.probe</strong>函数。</p>
<h2 id="i2c-client"><a href="#i2c-client" class="headerlink" title="i2c_client"></a>i2c_client</h2><p>参考资料 Linux内核文档: 5.0版本内核</p>
<ul>
<li><code>Documentation\i2c\instantiating-devices.rst</code></li>
<li><code>Documentation\i2c\writing-clients.rst</code></li>
</ul>
<p>i2c_client表示一个I2C设备，创建i2c_client的方法有4种：</p>
<ul>
<li><p>方法1</p>
<ul>
<li>通过I2C bus number来创建</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_register_board_info</span><span class="params">(<span class="keyword">int</span> busnum, struct i2c_board_info <span class="keyword">const</span> *info, <span class="keyword">unsigned</span> len)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过设备树结点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在某个I2C控制器的节点下，添加如下代码： */</span>		</span><br><span class="line">		ap3216c@<span class="number">1</span>e &#123;</span><br><span class="line">			compatible = <span class="string">&quot;lite-on,ap3216c&quot;</span>;</span><br><span class="line">			reg = &lt;<span class="number">0x1e</span>&gt;;</span><br><span class="line">		&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>方法2</p>
<p>有时候无法知道该设备挂载哪个I2C bus下，无法知道它对应的I2C bus number。<br>但是可以通过其他方法知道对应的i2c_adapter结构体。<br>可以使用下面两个函数来创建i2c_client：</p>
<ul>
<li>i2c_new_device</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">ap3216c_client</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">i2c_client_ap3216c_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> <span class="title">board_info</span> =</span> &#123;</span><br><span class="line">        I2C_BOARD_INFO(<span class="string">&quot;ap3216c&quot;</span>, <span class="number">0x1e</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;%s %s %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    <span class="comment">/* register I2C device */</span></span><br><span class="line">    adapter = i2c_get_adapter(<span class="number">0</span>);</span><br><span class="line">    ap3216c_client = i2c_new_device(adapter, &amp;board_info);</span><br><span class="line">    i2c_put_adapter(adapter);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>i2c_new_probed_device</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">ap3216c_client</span>;</span></span><br><span class="line"><span class="comment">/* 罗列出所有可能的地址,这里只有一个*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> normal_i2c[] = &#123; <span class="number">0x1e</span>, I2C_CLIENT_END &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">i2c_client_ap3216c_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> <span class="title">i2c_info</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将名字信息写入i2c_info,先清0 */</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;i2c_info, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct i2c_board_info));</span><br><span class="line">	strscpy(i2c_info.type, <span class="string">&quot;ap3216c&quot;</span>, <span class="keyword">sizeof</span>(i2c_info.type));</span><br><span class="line"></span><br><span class="line">    adapter = i2c_get_adapter(<span class="number">0</span>); <span class="comment">/* 第0根i2c总线 */</span></span><br><span class="line">	ap3216c_client = i2c_new_probed_device(adapter, &amp;i2c_info,</span><br><span class="line">						   normal_i2c, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	i2c_put_adapter(adapter);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>差别</p>
<ul>
<li><p>i2c_new_device：</p>
<p>会创建i2c_client，即使该设备并不存在</p>
</li>
<li><p>i2c_new_probed_device：</p>
<p>它成功的话，会创建i2c_client，并且表示这个设备肯定存在</p>
<p>I2C设备的地址可能发生变化，比如AT24C02的引脚A2A1A0电平不一样时，设备地址就不一样</p>
<p>可以罗列出可能的地址</p>
<p>i2c_new_probed_device使用这些地址判断设备是否存在</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>方法3 (不推荐)：由i2c_driver.detect函数来判断是否有对应的I2C设备并生成i2c_client</p>
</li>
<li><p>方法4 : 通过用户空间(user-space)生成</p>
<p>调试时、或者不方便通过代码明确地生成i2c_client时，可以通过用户空间来生成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个i2c_client, .name = &quot;eeprom&quot;, .addr=0x50, .adapter是i2c-3</span></span><br><span class="line"><span class="meta"># echo eeprom 0x50 &gt; /sys/bus/i2c/devices/i2c-3/new_device</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除一个i2c_client</span></span><br><span class="line"><span class="meta"># echo 0x50 &gt; /sys/bus/i2c/devices/i2c-3/delete_device</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="SMBus协议"><a href="#SMBus协议" class="headerlink" title="SMBus协议"></a>SMBus协议</h1><p>参考资料：</p>
<ul>
<li><p>Linux内核文档：<code>Documentation\i2c\smbus-protocol.rst</code></p>
</li>
<li><p>Linux内核代码：<code>drivers\i2c\i2c-core.c</code></p>
</li>
<li><p>SMBus协议：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.smbus.org/specs/">http://www.smbus.org/specs/</a></li>
</ul>
</li>
</ul>
<h2 id="SMBus是I2C协议的一个子集。"><a href="#SMBus是I2C协议的一个子集。" class="headerlink" title="SMBus是I2C协议的一个子集。"></a>SMBus是I2C协议的一个子集。</h2><p>SMBus: System Management Bus，系统管理总线。</p>
<p>SMBus最初的目的是为智能电池、充电电池、其他微控制器之间的通信链路而定义的。<br>SMBus也被用来连接各种设备，包括电源相关设备，系统传感器，EEPROM通讯设备等等。<br>SMBus 为系统和电源管理这样的任务提供了一条控制总线，使用 SMBus 的系统，设备之间发送和接收消息都是通过 SMBus，而不是使用单独的控制线，这样可以节省设备的管脚数。<br>SMBus是基于I2C协议的，但SMBus要求更严格。</p>
<p><img src="/2021/09/12/Linux%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/NO2.png" alt="image"></p>
<p>如今很多设备都实现了SMBus，即使I2C控制器没有实现SMBus，软件方面也是可以使用I2C协议来模拟SMBus。<br><strong>在Linux上建议优先使用SMBus</strong>。</p>
<h2 id="SMBus与一般I2C协议的差别"><a href="#SMBus与一般I2C协议的差别" class="headerlink" title="SMBus与一般I2C协议的差别"></a>SMBus与一般I2C协议的差别</h2><ul>
<li><p>VDD的极限值不一样</p>
<ul>
<li>I2C协议：范围很广，甚至讨论了高达12V的情况</li>
<li>SMBus：1.8V~5V</li>
</ul>
</li>
<li><p>最小时钟频率、最大的<code>Clock Stretching </code></p>
<ul>
<li><p>Clock Stretching含义：某个设备需要更多时间进行内部的处理时，它可以把SCL拉低占住I2C总线</p>
</li>
<li><p>I2C协议：时钟频率最小值无限制，Clock Stretching时长也没有限制</p>
</li>
<li><p>SMBus：时钟频率最小值是10KHz，Clock Stretching的最大时间值也有限制</p>
</li>
</ul>
</li>
<li><p>地址回应(Address Acknowledge)</p>
<ul>
<li>I2C协议：没有强制要求必须发出回应信号</li>
<li>SMBus：强制要求必须发出回应信号，这样对方才知道该设备的状态：busy，failed，或是被移除了</li>
</ul>
</li>
<li><p>SMBus协议明确了数据的传输格式</p>
<ul>
<li>I2C协议：它只定义了怎么传输数据，但是并没有定义数据的格式，这完全由设备来定义</li>
<li>SMBus：定义了几种数据格式</li>
</ul>
</li>
<li><p>REPEATED START Condition(重复发出S信号)</p>
<ul>
<li>比如读EEPROM时，涉及2个操作：<ul>
<li>把存储地址发给设备</li>
<li>读数据</li>
</ul>
</li>
<li>在写、读之间，可以不发出P信号，而是直接发出S信号：这个S信号就是<code>REPEATED START</code></li>
<li>如下图所示<br><img src="/2021/09/12/Linux%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/NO3.png" alt="image"></li>
</ul>
</li>
<li><p>SMBus Low Power Version </p>
<ul>
<li>SMBus也有低功耗的版本</li>
</ul>
</li>
</ul>
<h2 id="SMBus通信"><a href="#SMBus通信" class="headerlink" title="SMBus通信"></a>SMBus通信</h2><p>Linux内核上集成了SMBus，可以认为是对I2C的进一步封装，在与外设使用I2C子系统进行数据传输时，建议使用SMBus协议。</p>
<p>以下是常用的SMBus函数，更多资料参考内核源码：<code>drivers\i2c\i2c-core.c</code></p>
<h3 id="Receive-Byte"><a href="#Receive-Byte" class="headerlink" title="Receive Byte"></a>Receive Byte</h3><p><img src="/2021/09/12/Linux%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/04_smbus_receive_byte.png" alt="image"></p>
<p>读取一个字节，主机接收到一个字节后不需要回应(上图中N表示不回应)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_smbus_read_byte - SMBus &quot;receive byte&quot; protocol</span></span><br><span class="line"><span class="comment"> * @client: Handle to slave device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This executes the SMBus &quot;receive byte&quot; protocol, returning negative errno</span></span><br><span class="line"><span class="comment"> * else the byte received from the device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">s32 <span class="title">i2c_smbus_read_byte</span><span class="params">(<span class="keyword">const</span> struct i2c_client *client)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Send-Byte"><a href="#Send-Byte" class="headerlink" title="Send Byte"></a>Send Byte</h3><p><img src="/2021/09/12/Linux%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/05_smbus_send_byte.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_smbus_write_byte - SMBus &quot;send byte&quot; protocol</span></span><br><span class="line"><span class="comment"> * @client: Handle to slave device</span></span><br><span class="line"><span class="comment"> * @value: Byte to be sent</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This executes the SMBus &quot;send byte&quot; protocol, returning negative errno</span></span><br><span class="line"><span class="comment"> * else zero on success.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">s32 <span class="title">i2c_smbus_write_byte</span><span class="params">(<span class="keyword">const</span> struct i2c_client *client, u8 value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i2c_smbus_xfer(client-&gt;adapter, client-&gt;addr, client-&gt;flags,</span><br><span class="line">	                      I2C_SMBUS_WRITE, value, I2C_SMBUS_BYTE, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Read-Byte"><a href="#Read-Byte" class="headerlink" title="Read Byte"></a>Read Byte</h3><p><img src="/2021/09/12/Linux%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/06_smbus_read_byte.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_smbus_read_byte_data - SMBus &quot;read byte&quot; protocol</span></span><br><span class="line"><span class="comment"> * @client: Handle to slave device</span></span><br><span class="line"><span class="comment"> * @command: Byte interpreted by slave</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This executes the SMBus &quot;read byte&quot; protocol, returning negative errno</span></span><br><span class="line"><span class="comment"> * else a data byte received from the device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">s32 <span class="title">i2c_smbus_read_byte_data</span><span class="params">(<span class="keyword">const</span> struct i2c_client *client, u8 command)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">i2c_smbus_data</span> <span class="title">data</span>;</span></span><br><span class="line">	<span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">	status = i2c_smbus_xfer(client-&gt;adapter, client-&gt;addr, client-&gt;flags,</span><br><span class="line">				I2C_SMBUS_READ, command,</span><br><span class="line">				I2C_SMBUS_BYTE_DATA, &amp;data);</span><br><span class="line">	<span class="keyword">return</span> (status &lt; <span class="number">0</span>) ? status : data.byte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Read-Word"><a href="#Read-Word" class="headerlink" title="Read Word"></a>Read Word</h3><p><img src="/2021/09/12/Linux%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/07_smbus_read_word.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_smbus_read_word_data - SMBus &quot;read word&quot; protocol</span></span><br><span class="line"><span class="comment"> * @client: Handle to slave device</span></span><br><span class="line"><span class="comment"> * @command: Byte interpreted by slave</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This executes the SMBus &quot;read word&quot; protocol, returning negative errno</span></span><br><span class="line"><span class="comment"> * else a 16-bit unsigned &quot;word&quot; received from the device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">s32 <span class="title">i2c_smbus_read_word_data</span><span class="params">(<span class="keyword">const</span> struct i2c_client *client, u8 command)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">i2c_smbus_data</span> <span class="title">data</span>;</span></span><br><span class="line">	<span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">	status = i2c_smbus_xfer(client-&gt;adapter, client-&gt;addr, client-&gt;flags,</span><br><span class="line">				I2C_SMBUS_READ, command,</span><br><span class="line">				I2C_SMBUS_WORD_DATA, &amp;data);</span><br><span class="line">	<span class="keyword">return</span> (status &lt; <span class="number">0</span>) ? status : data.word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Write-Byte"><a href="#Write-Byte" class="headerlink" title="Write Byte"></a>Write Byte</h3><p><img src="/2021/09/12/Linux%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/08_smbus_write_byte.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_smbus_write_byte_data - SMBus &quot;write byte&quot; protocol</span></span><br><span class="line"><span class="comment"> * @client: Handle to slave device</span></span><br><span class="line"><span class="comment"> * @command: Byte interpreted by slave</span></span><br><span class="line"><span class="comment"> * @value: Byte being written</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This executes the SMBus &quot;write byte&quot; protocol, returning negative errno</span></span><br><span class="line"><span class="comment"> * else zero on success.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">s32 <span class="title">i2c_smbus_write_byte_data</span><span class="params">(<span class="keyword">const</span> struct i2c_client *client, u8 command,</span></span></span><br><span class="line"><span class="params"><span class="function">			      u8 value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">i2c_smbus_data</span> <span class="title">data</span>;</span></span><br><span class="line">	data.byte = value;</span><br><span class="line">	<span class="keyword">return</span> i2c_smbus_xfer(client-&gt;adapter, client-&gt;addr, client-&gt;flags,</span><br><span class="line">			      I2C_SMBUS_WRITE, command,</span><br><span class="line">			      I2C_SMBUS_BYTE_DATA, &amp;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Write-Word"><a href="#Write-Word" class="headerlink" title="Write Word"></a>Write Word</h3><p><img src="/2021/09/12/Linux%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/09_smbus_write_word.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_smbus_write_word_data - SMBus &quot;write word&quot; protocol</span></span><br><span class="line"><span class="comment"> * @client: Handle to slave device</span></span><br><span class="line"><span class="comment"> * @command: Byte interpreted by slave</span></span><br><span class="line"><span class="comment"> * @value: 16-bit &quot;word&quot; being written</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This executes the SMBus &quot;write word&quot; protocol, returning negative errno</span></span><br><span class="line"><span class="comment"> * else zero on success.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">s32 <span class="title">i2c_smbus_write_word_data</span><span class="params">(<span class="keyword">const</span> struct i2c_client *client, u8 command,</span></span></span><br><span class="line"><span class="params"><span class="function">			      u16 value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">i2c_smbus_data</span> <span class="title">data</span>;</span></span><br><span class="line">	data.word = value;</span><br><span class="line">	<span class="keyword">return</span> i2c_smbus_xfer(client-&gt;adapter, client-&gt;addr, client-&gt;flags,</span><br><span class="line">			      I2C_SMBUS_WRITE, command,</span><br><span class="line">			      I2C_SMBUS_WORD_DATA, &amp;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"># Linux</a>
              <a href="/tags/driver/" rel="tag"># driver</a>
              <a href="/tags/I2C/" rel="tag"># I2C</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/09/12/vim/vim%E5%8C%B9%E9%85%8D/" rel="prev" title="Vim匹配">
                  <i class="fa fa-chevron-left"></i> Vim匹配
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/09/12/Linux%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/" rel="next" title="SPI子系统">
                  SPI子系统 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">huahui</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
