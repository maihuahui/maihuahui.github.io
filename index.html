<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.7.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="Huahui">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Huahui">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="huahui">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Huahui</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Huahui</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">huahui</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/15/makefile-makefile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="huahui">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huahui">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/15/makefile-makefile/" class="post-title-link" itemprop="url">Makefile 特殊符号</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-15 20:00:52 / Modified: 20:01:39" itemprop="dateCreated datePublished" datetime="2022-02-15T20:00:52+08:00">2022-02-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/makefile/" itemprop="url" rel="index"><span itemprop="name">makefile</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Makefile-特殊符号"><a href="#Makefile-特殊符号" class="headerlink" title="Makefile 特殊符号"></a>Makefile 特殊符号</h1><p> <code>- @ + $ $$</code></p>
<h2 id="符号-连字符"><a href="#符号-连字符" class="headerlink" title="- 符号 (连字符)"></a><code>-</code> 符号 (连字符)</h2><p>任何命令行的任何非零退出状态都被忽略，忽略当前命令行执行时所遇到的错误。<br>make 在执行命令的时候，如果遇到 error，会退出执行。加上减号的目的是即便此命令行执行出错，那么也不要管，继续执行 make。<br>通常删除或者创建文件时，遇到文件不存在或者已经创建。如果希望忽略掉错误，继续执行，就可以在命令行前面添加 <code>-</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">	-rm $(objects)</span><br></pre></td></tr></table></figure>
<h2 id="符号-at-符号"><a href="#符号-at-符号" class="headerlink" title="@ 符号 (at 符号)"></a><code>@</code> 符号 (at 符号)</h2><p>通常 makefile 会将其执行的命令行在执行前输出到屏幕上。如果将 @ 添加到命令行前，这个命令将不被 make 回显出来，<strong>即不显示命令本身而只显示结果</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">all :</span><br><span class="line">	@echo &quot;Make&quot;</span><br></pre></td></tr></table></figure>
<h2 id="符号-加号"><a href="#符号-加号" class="headerlink" title="+ 符号 (加号)"></a><code>+</code> 符号 (加号)</h2><p>使用加号修饰符让命令始终执行。命令行执行时不受到 make 的 -n -t -q 三个参数的影响，忽略这三个参数。<br>如果 make 执行时，使用 -n 或 –just-print。该参数显示命令，不会执行命令。这个功能有利于调试 Makefile，方便查看执行的命令形式和顺序。</p>
<h2 id="符号-美元符号"><a href="#符号-美元符号" class="headerlink" title="$ 符号 (美元符号)"></a><code>$</code> 符号 (美元符号)</h2><p>美元符号 <code>$</code>，扩展打开 makefile 中定义的变量。</p>
<h2 id="符号"><a href="#符号" class="headerlink" title="$$ 符号"></a><code>$$</code> 符号</h2><p><code>$$</code> 符号，扩展打开 makefile 中定义的 shell 变量。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/15/gdb-gdb-memory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="huahui">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huahui">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/15/gdb-gdb-memory/" class="post-title-link" itemprop="url">GDB 内存操作</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-15 19:59:04 / Modified: 20:01:54" itemprop="dateCreated datePublished" datetime="2022-02-15T19:59:04+08:00">2022-02-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/gdb/" itemprop="url" rel="index"><span itemprop="name">gdb</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="gdb查看内存数据"><a href="#gdb查看内存数据" class="headerlink" title="gdb查看内存数据"></a>gdb查看内存数据</h1><p>格式: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/nfu</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li><code>x</code> 是 examine 的缩写，意思是检查</li>
<li><code>n</code>表示要显示的内存单元的个数</li>
<li><code>f</code>表示显示方式</li>
<li><code>u</code>表示一个地址单元的长度：</li>
</ul>
<h2 id="显示方式-f-取值"><a href="#显示方式-f-取值" class="headerlink" title="显示方式 f 取值"></a>显示方式 f 取值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x 按十六进制格式显示变量。</span><br><span class="line">d 按十进制格式显示变量。</span><br><span class="line">u 按十进制格式显示无符号整型。</span><br><span class="line">o 按八进制格式显示变量。</span><br><span class="line">t 按二进制格式显示变量。</span><br><span class="line">a 按十六进制格式显示变量。</span><br><span class="line">i 指令地址格式</span><br><span class="line">c 按字符格式显示变量。</span><br><span class="line">f 按浮点数格式显示变量。</span><br></pre></td></tr></table></figure>
<h2 id="地址单元长度-u-取值"><a href="#地址单元长度-u-取值" class="headerlink" title="地址单元长度 u 取值"></a>地址单元长度 u 取值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b表示单字节，</span><br><span class="line">h表示双字节，</span><br><span class="line">w表示四字节，</span><br><span class="line">g表示八字节</span><br></pre></td></tr></table></figure>

<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x/50xw 0x40451400</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>50</code>是数量，<code>x</code>是16进制，<code>w</code>是四字节</p>
<h1 id="Examining-Memory"><a href="#Examining-Memory" class="headerlink" title="Examining Memory"></a>Examining Memory</h1><p>You can use the command <code>x</code> (for “examine”) to examine memory in any of several formats, independently of your program’s data types.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x/nfu addr</span><br><span class="line">x addr</span><br><span class="line">x</span><br></pre></td></tr></table></figure>

<p>Use the x command to examine memory.</p>
<p><code>n</code>, <code>f</code>, and <code>u</code> are all optional parameters that specify how much memory to display and how to format it; addr is an expression giving the address where you want to start displaying memory. If you use defaults for nfu, you need not type the slash ‘/’. Several commands set convenient defaults for addr.</p>
<h2 id="n-the-repeat-count"><a href="#n-the-repeat-count" class="headerlink" title="n, the repeat count"></a>n, the repeat count</h2><pre><code>The repeat count is a decimal integer; the default is 1. 
It specifies how much memory (counting by units u) to display. 
If a negative number is specified, memory is examined backward from addr.
</code></pre>
<h2 id="f-the-display-format"><a href="#f-the-display-format" class="headerlink" title="f, the display format"></a>f, the display format</h2><pre><code>The display format is one of the formats used by print 
(‘x’, ‘d’, ‘u’, ‘o’, ‘t’, ‘a’, ‘c’, ‘f’, ‘s’), 
‘i’ (for machine instructions) and ‘m’ (for displaying memory tags). 
The default is ‘x’ (hexadecimal) initially. 
The default changes each time you use either x or print.
</code></pre>
<h2 id="u-the-unit-size"><a href="#u-the-unit-size" class="headerlink" title="u, the unit size"></a>u, the unit size</h2><p>The unit size is any of</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">b</span><br><span class="line">Bytes.</span><br><span class="line"></span><br><span class="line">h</span><br><span class="line">Halfwords (two bytes).</span><br><span class="line"></span><br><span class="line">w</span><br><span class="line">Words (four bytes). This is the initial default.</span><br><span class="line"></span><br><span class="line">g</span><br><span class="line">Giant words (eight bytes).</span><br></pre></td></tr></table></figure>

<ul>
<li>Each time you specify a unit size with x, that size becomes the default unit the next time you use x. </li>
<li>For the ‘i’ format, the unit size is ignored and is normally not written. </li>
<li>For the ‘s’ format, the unit size defaults to ‘b’, unless it is explicitly given. </li>
<li>Use x /hs to display 16-bit char strings and x /ws to display 32-bit strings. The next use of x /s will again display 8-bit strings. </li>
<li>Note that the results depend on the programming language of the current compilation unit. </li>
<li>If the language is C, the ‘s’ modifier will use the UTF-16 encoding while ‘w’ will use UTF-32. The encoding is set by the programming language and cannot be altered.</li>
</ul>
<h1 id="modify-memory"><a href="#modify-memory" class="headerlink" title="modify memory"></a>modify memory</h1><p>In order to set the variable g, use </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set var g=4</span><br></pre></td></tr></table></figure>
<p>GDB allows more implicit conversions in assignments than C; you can freely store an integer value into a pointer variable or vice versa,<br>and you can convert any structure to any other structure that is the same length or shorter.</p>
<p>To store values into arbitrary places in memory, use the ‘{…}’ construct to generate a value of specified type at a specified address (see Expressions).<br>For example, {int}0x83040 refers to memory location 0x83040 as an integer (which implies a certain size and representation in memory), and</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set &#123;int&#125;0x83040 = 4</span><br></pre></td></tr></table></figure>
<p>stores the value 4 into that memory location.</p>
<p>This should work for any valid pointer, and can be cast to any appropriate data type.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set *((int *) 0xbfbb0000) = 20</span><br></pre></td></tr></table></figure>

<p>e.g.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">set *(unsigned char      *)&lt;memaddr&gt; = &lt;value&gt;  ; write 1 byte</span><br><span class="line">set *(unsigned short     *)&lt;memaddr&gt; = &lt;value&gt;  ; write 2 bytes</span><br><span class="line">set *(unsigned int       *)&lt;memaddr&gt; = &lt;value&gt;  ; write 4 bytes</span><br><span class="line">set *(unsigned long long *)&lt;memaddr&gt; = &lt;value&gt;  ; write 8 bytes</span><br><span class="line"> </span><br><span class="line">or</span><br><span class="line"> </span><br><span class="line">set *(char      *)&lt;memaddr&gt; = &lt;value&gt;           ; write 1 byte</span><br><span class="line">set *(short     *)&lt;memaddr&gt; = &lt;value&gt;           ; write 2 bytes</span><br><span class="line">set *(int       *)&lt;memaddr&gt; = &lt;value&gt;           ; write 4 bytes</span><br><span class="line">set *(long long *)&lt;memaddr&gt; = &lt;value&gt;           ; write 8 bytes</span><br></pre></td></tr></table></figure>

<p>or use</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set *0xbfbb0000=20</span><br></pre></td></tr></table></figure>
<p>change memory locations directly.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/13/C%E7%BC%96%E7%A8%8B-inline/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="huahui">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huahui">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/13/C%E7%BC%96%E7%A8%8B-inline/" class="post-title-link" itemprop="url">Inline</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-13 16:08:56 / Modified: 16:48:59" itemprop="dateCreated datePublished" datetime="2022-02-13T16:08:56+08:00">2022-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">C编程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h1><p>有些函数短小精悍而且调用频繁，调用开销大，经常保护现场，恢复现场，算下来性价比不高。这时就可以将这个函数声明为内联函数。编译器在编译过程中遇到内联函数，<strong>像宏一样，将内联函数直接在调用处展开</strong>，这样就可以减少函数调用的开支：<strong>直接执行内联函数展开的代码，不用再保存现场和恢复现场</strong>。</p>
<h2 id="内联函数和宏"><a href="#内联函数和宏" class="headerlink" title="内联函数和宏"></a>内联函数和宏</h2><p>内联函数和宏的功能差不多，为什么不直接定义一个宏定义？而是定义一个内联函数？</p>
<p>存在即合理，内联函数在 C 语言中有广泛运用，自然有其原因。与宏相比，内联函数有以下优势：</p>
<ul>
<li><p>参数类型检查</p>
<pre><code>    内联函数随有宏的展开特性，但其本质仍是函数，在编译过程中，编译器仍可以对其进行参数检查，而宏不具备这个功能。
</code></pre>
</li>
<li><p>便于调试</p>
<p>​        函数支持的调试功能有断点、单步等，内联函数同样支持。        </p>
</li>
<li><p>返回值</p>
<p>​        内联函数有返回值，返回一个结果给调用者。这个优势是相对 ANSI C 说的，因为现在宏也可以有返回值和类型了，如前面使用语句表达式的宏。</p>
</li>
<li><p>接口封装</p>
<p>​        有些内联函数可以用来封装一个接口，而宏不具备这个功能。</p>
</li>
</ul>
<h2 id="内联函数不足"><a href="#内联函数不足" class="headerlink" title="内联函数不足"></a>内联函数不足</h2><p>内联函数并不是完美无瑕的，也存在不足。</p>
<ul>
<li>内联函数会增大函数体积。<br>  如果一个文件中多次调用内联函数，多次展开，那整个程序的体积就会变大，在一定程度上会减低程序的执行效率。</li>
<li>减低代码复用性。<br>  函数的作用之一就是提高代码的复用性。我们将一些代码封装成函数，进行模块化编程，可以减轻软件开发的工作量，而内联函数往往又减低函数的复用性。</li>
</ul>
<h2 id="编译器对内联函数的处理"><a href="#编译器对内联函数的处理" class="headerlink" title="编译器对内联函数的处理"></a>编译器对内联函数的处理</h2><p>我们通过 <code>inline</code>关键字将一个函数声明为内联函数，但编译器不一定会对这个内联函数在进行展开。编译器也要根据实际情况进行评估。除了检测用户定义的内联函数是否含有指针、循环、递归，还会在函数执行效率和函数调用开销之间进行权衡。</p>
<p>从程序员角度出发，是否展开主要考虑如下因素：</p>
<ul>
<li>函数体积大小</li>
<li>函数体内无指针赋值、递归、循环等语句</li>
<li>调用频繁</li>
</ul>
<p>当我们认为一个函数体积小，而且被大量调用，应该做内联展开。</p>
<h3 id="属性声明：noinline"><a href="#属性声明：noinline" class="headerlink" title="属性声明：noinline"></a>属性声明：noinline</h3><p>明确告诉编译器不展开内联函数</p>
<h3 id="属性声明：always-inline"><a href="#属性声明：always-inline" class="headerlink" title="属性声明：always_inline"></a>属性声明：always_inline</h3><p>明确告诉编译器展开内联函数</p>
<h2 id="内联函数定义在头文件中"><a href="#内联函数定义在头文件中" class="headerlink" title="内联函数定义在头文件中"></a>内联函数定义在头文件中</h2><p>在Linux 内核中，有大量的内联函数被定义在头文件中，而且经常使用 <code>static</code>修饰。</p>
<p>Q: 为什么内联函数要定义在头文件中？</p>
<blockquote>
<p> A: 因为它是一个内联函数，可以像宏一样展开，任何像使用这个内联函数的源文件，都不必亲自去定义一遍，直接包含这个头文件即可，即像宏定义一样使用。</p>
</blockquote>
<p>Q：为什么要加<code>static</code>修饰</p>
<blockquote>
<p>inline 定义的内联函数不一定会展开，当一个工程中多个文件都包含这个内联函数的定义时，编译时就有可能报重定义错误。使用 static 关键字修饰，则可以将这个函数的作用域限制在各自的文件内，避免重定义错误的发生。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/13/Linux%E9%A9%B1%E5%8A%A8-LCD%E9%A9%B1%E5%8A%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="huahui">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huahui">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/13/Linux%E9%A9%B1%E5%8A%A8-LCD%E9%A9%B1%E5%8A%A8/" class="post-title-link" itemprop="url">Framebuffer</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-13 15:58:36 / Modified: 16:05:09" itemprop="dateCreated datePublished" datetime="2022-02-13T15:58:36+08:00">2022-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux%E9%A9%B1%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">Linux驱动</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>像素颜色</p>
<p>用红绿蓝三颜色来表示，可以用24位数据来表示红绿蓝，也可以用16位等等格式，比如：</p>
<ul>
<li>bpp：bits per pixel，每个像素用多少位来表示</li>
<li>24bpp：实际上会用到32位，其中8位未使用，其余24位中分别用8位表示红(R)、绿(G)、蓝(B) 。24位使用32位来存储方便寻址。</li>
<li>16bpp：有rbg565，rgb555<ul>
<li>rgb565：用5位表示红、6位表示绿、5位表示蓝。人眼对绿色较敏感，能分辨出其中的细微差别</li>
<li>rgb555：16位数据中用5位表示红、5位表示绿、5位表示蓝，浪费一位</li>
</ul>
</li>
</ul>
<p><img src="002_rgb.png"></p>
<p>注：有些LCD控制器可以设置红绿蓝三原色的位置，比如24位的数据里，可能是RGB888，也可能是BGR888</p>
<h1 id="Framebuffer"><a href="#Framebuffer" class="headerlink" title="Framebuffer"></a>Framebuffer</h1><p>存储像素数据的一块特殊内存，<strong>显存</strong></p>
<ul>
<li>也有芯片手册称为 <strong>GRAM</strong>, G指图形</li>
</ul>
<h2 id="对于应用工程师"><a href="#对于应用工程师" class="headerlink" title="对于应用工程师"></a>对于<strong>应用工程师</strong></h2><p>使用LCD只需要掌握三点：</p>
<ol>
<li>颜色格式：16bpp/24bpp</li>
<li>Framebuffer基地址</li>
<li>LCD屏幕分辨率，根据分辨率才能找到像素点在显存的任意位置</li>
</ol>
<p>应用工程师将数据写入Framebuffer即可，LCD controler （LCD控制器）会帮助更新屏幕上像素的颜色。</p>
<h2 id="对于驱动工程师"><a href="#对于驱动工程师" class="headerlink" title="对于驱动工程师"></a>对于驱动工程师</h2><p>对LCD的理解要深入硬件，比如要回答这几个问题：</p>
<ul>
<li>Framebuffer在哪里？</li>
</ul>
<p>LCD里面还是LCD外面</p>
<ul>
<li>谁把Framebuffer中的数据发给LCD？</li>
</ul>
<p>LCD controler，驱动工程师很大一部分工作既是设置初始化LCD controler</p>
<h1 id="统一的硬件模型"><a href="#统一的硬件模型" class="headerlink" title="统一的硬件模型"></a>统一的硬件模型</h1><p>LCD接口众多，但硬件模型一致，原理一致</p>
<p><img src="004_lcd_hardware_block.png"></p>
<h2 id="MCU常用的8080接口LCD模组"><a href="#MCU常用的8080接口LCD模组" class="headerlink" title="MCU常用的8080接口LCD模组"></a>MCU常用的8080接口LCD模组</h2><p>内存，LCD控制器，LCD屏幕组合成一个<strong>LCM模组</strong>，单片机F103直接跟模组通信</p>
<p>F103一般通过以下信号线跟LCM模组通信</p>
<ul>
<li>CS 片选线</li>
<li>RD / WD 读写控制线</li>
<li>DataBus 数据总线</li>
<li>Data / cmd 控制引脚，决定DataBus上传输的是数据还是地址等其他信息</li>
</ul>
<h2 id="MPU常用的TFT-RGB接口"><a href="#MPU常用的TFT-RGB接口" class="headerlink" title="MPU常用的TFT RGB接口"></a>MPU常用的TFT RGB接口</h2><p>只有LCD屏幕在外面，LCD控制器位于ARM芯片内部，可外接显存。LCD控制器通过RGB三组线以及其他控制信号线对LCD屏幕进行控制</p>
<ul>
<li>DCLK 移动一个像素点</li>
<li>HSYNC 从最右跳到下一行</li>
<li>VSYNC 从最后一个跳到第一个</li>
<li>DE 决定是否接受RGB数据，在像素点跳转时禁用RGB数据</li>
</ul>
<h2 id="RGB三组线"><a href="#RGB三组线" class="headerlink" title="RGB三组线"></a>RGB三组线</h2><ul>
<li><p>对于使用真彩色的LCD控制器，RGB引脚上的数据直接来自自Framebuffer；</p>
</li>
<li><p>对于使用调色板的LCD控制器，Framebuffer中的数据只是用来取出调色板中的颜色，调色板中的数据会被放到RGB引脚上去。</p>
</li>
</ul>
<h1 id="编写Framebuffer框架"><a href="#编写Framebuffer框架" class="headerlink" title="编写Framebuffer框架"></a>编写Framebuffer框架</h1><p>分配显存时，不可以使用kmalloc函数。</p>
<p>显存要保证物理地址连续，kamlloc函数分配的内存可以保证虚拟地址的联系，但在物理地址上不一定是连续的。</p>
<p>Framebuffer框架分为上下两层：</p>
<ul>
<li>fbmem.c：承上启下<ul>
<li>实现、注册file_operations结构体</li>
<li>把APP的调用向下转发到具体的硬件驱动程序</li>
</ul>
</li>
<li>xxx_fb.c：硬件相关的驱动程序<ul>
<li>实现、注册fb_info结构体</li>
<li>实现硬件操作</li>
</ul>
</li>
</ul>
<h2 id="Framebuffer核心："><a href="#Framebuffer核心：" class="headerlink" title="Framebuffer核心："></a>Framebuffer核心：</h2><ul>
<li><p>分配fb_info</p>
<ul>
<li>framebuffer_alloc</li>
</ul>
</li>
<li><p>设置fb_info</p>
<ul>
<li>var</li>
<li>fbops</li>
<li>硬件相关操作</li>
</ul>
</li>
<li><p>注册fb_info</p>
<ul>
<li>register_framebuffer</li>
</ul>
</li>
</ul>
<h1 id="imx6ull-LCD-控制器"><a href="#imx6ull-LCD-控制器" class="headerlink" title="imx6ull LCD 控制器"></a>imx6ull LCD 控制器</h1><h2 id="控制器模块"><a href="#控制器模块" class="headerlink" title="控制器模块"></a>控制器模块</h2><ul>
<li>硬件框架</li>
<li>数据传输与处理</li>
<li>时序控制</li>
</ul>
<p>数据处理过程</p>
<ol>
<li>从显存读数据 32bit * n</li>
<li>判断是否交换</li>
<li>使用哪种RGB格式 RGB555， RGB565, RGB888</li>
<li>设置时序，用于发送数据</li>
<li>RGB 数据格式 跟LCD屏幕匹配</li>
</ol>
<p>例如：RGB 888 - &gt; 16bpp的LCD ，在8位中只传五位</p>
<h2 id="LCD控制器寄存器简介"><a href="#LCD控制器寄存器简介" class="headerlink" title="LCD控制器寄存器简介"></a>LCD控制器寄存器简介</h2><p>查看任何芯片的LCD控制器寄存器时，记住几个要点：</p>
<p>① 怎么把LCD的信息告诉LCD控制器：即分辨率、行列时序、像素时钟等；<br>② 怎么把显存地址、像素格式告诉LCD控制器。</p>
<h1 id="内核中的LCD驱动程序"><a href="#内核中的LCD驱动程序" class="headerlink" title="内核中的LCD驱动程序"></a>内核中的LCD驱动程序</h1><p>如何确定内存LCD驱动程序</p>
<p>在已经编译好的内核中 <code>drivers/video/fbdev</code>目录下，有哪些<code>.o</code>文件，对应的<code>.c</code>文件。</p>
<h1 id="编程-LCD驱动程序框架-使用设备树"><a href="#编程-LCD驱动程序框架-使用设备树" class="headerlink" title="编程_LCD驱动程序框架_使用设备树"></a>编程_LCD驱动程序框架_使用设备树</h1><p>Linux驱动程序 = 驱动程序框架 + 硬件编程。</p>
<p>驱动程序框架核心就是：</p>
<ul>
<li>分配fb_info</li>
<li>设置fb_info</li>
<li>注册fb_info</li>
<li>硬件相关的设置</li>
</ul>
<h2 id="硬件相关的设置"><a href="#硬件相关的设置" class="headerlink" title="硬件相关的设置"></a>硬件相关的设置</h2><ul>
<li>引脚设置</li>
<li>时钟设置</li>
<li>LCD控制器设置</li>
</ul>
<p>入口函数注册<code>platform_driver</code></p>
<p>设备树结点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">framebuffer-mylcd &#123;</span><br><span class="line">        compatible = &quot;huahui,lcd_drv&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="编写probe函数"><a href="#编写probe函数" class="headerlink" title="编写probe函数"></a>编写probe函数</h2><ul>
<li>驱动程序框架核心 fb_info</li>
<li>硬件相关的设置</li>
</ul>
<h1 id="引脚配置"><a href="#引脚配置" class="headerlink" title="引脚配置"></a>引脚配置</h1><p>主要使用<strong>pinctrl子系统</strong>把引脚配置为LCD功能，对于背光引脚等使用<strong>GPIO子系统</strong>的函数控制它的输出电平。</p>
<p>设备树结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">pinctrl<span class="number">-0</span> = &lt;&amp;pmylcd_pinctrl&gt;;</span><br><span class="line">backlight-gpios = &lt;&amp;gpio1 <span class="number">8</span> GPIO_ACTIVE_HIGH&gt;;</span><br></pre></td></tr></table></figure>



<h1 id="时钟配置"><a href="#时钟配置" class="headerlink" title="时钟配置"></a>时钟配置</h1><p>通过芯片手册，查看需要使能那些时钟</p>
<p>设备树结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clocks = &lt;&amp;clks IMX6UL_CLK_LCDIF_PIX&gt;,</span><br><span class="line">         &lt;&amp;clks IMX6UL_CLK_LCDIF_APB&gt;;</span><br><span class="line">clock-names = <span class="string">&quot;pix&quot;</span>, <span class="string">&quot;axi&quot;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="配置LCD控制器"><a href="#配置LCD控制器" class="headerlink" title="配置LCD控制器"></a>配置LCD控制器</h1><h2 id="在设备树里指定LCD参数"><a href="#在设备树里指定LCD参数" class="headerlink" title="在设备树里指定LCD参数"></a>在设备树里指定LCD参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">framebuffer-mylcd &#123;</span><br><span class="line">		compatible = &quot;100ask,lcd_drv&quot;;</span><br><span class="line">        pinctrl-names = &quot;default&quot;;</span><br><span class="line">		pinctrl-0 = &lt;&amp;mylcd_pinctrl&gt;;</span><br><span class="line">		backlight-gpios = &lt;&amp;gpio1 8 GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line"></span><br><span class="line">           clocks = &lt;&amp;clks IMX6UL_CLK_LCDIF_PIX&gt;,</span><br><span class="line">                    &lt;&amp;clks IMX6UL_CLK_LCDIF_APB&gt;;</span><br><span class="line">           clock-names = &quot;pix&quot;, &quot;axi&quot;;</span><br><span class="line">           </span><br><span class="line">           display = &lt;&amp;display0&gt;;</span><br><span class="line"></span><br><span class="line">		display0: display &#123;</span><br><span class="line">			bits-per-pixel = &lt;24&gt;;</span><br><span class="line">			bus-width = &lt;24&gt;;</span><br><span class="line"></span><br><span class="line">			display-timings &#123;</span><br><span class="line">				native-mode = &lt;&amp;timing0&gt;;</span><br><span class="line"></span><br><span class="line">				 timing0: timing0_1024x768 &#123;</span><br><span class="line">				 clock-frequency = &lt;50000000&gt;;</span><br><span class="line">				 hactive = &lt;1024&gt;;</span><br><span class="line">				 vactive = &lt;600&gt;;</span><br><span class="line">				 hfront-porch = &lt;160&gt;;</span><br><span class="line">				 hback-porch = &lt;140&gt;;</span><br><span class="line">				 hsync-len = &lt;20&gt;;</span><br><span class="line">				 vback-porch = &lt;20&gt;;</span><br><span class="line">				 vfront-porch = &lt;12&gt;;</span><br><span class="line">				 vsync-len = &lt;3&gt;;</span><br><span class="line"></span><br><span class="line">				 hsync-active = &lt;0&gt;;</span><br><span class="line">				 vsync-active = &lt;0&gt;;</span><br><span class="line">				 de-active = &lt;1&gt;;</span><br><span class="line">				 pixelclk-active = &lt;0&gt;;</span><br><span class="line">				 &#125;;</span><br><span class="line"></span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;            </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="从设备树获得参数"><a href="#从设备树获得参数" class="headerlink" title="从设备树获得参数"></a>从设备树获得参数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">u32 width;</span><br><span class="line">u32 bits_per_pixel;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">display_timings</span> *<span class="title">timings</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get display node from device tree , pdev-&gt;dev.of_node : from father node*/</span></span><br><span class="line">display_np = of_parse_phandle(pdev-&gt;dev.of_node, <span class="string">&quot;display&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get common info 通用属性 */</span></span><br><span class="line">ret = of_property_read_u32(display_np, <span class="string">&quot;bus-width&quot;</span>, &amp;width);</span><br><span class="line">ret = of_property_read_u32(display_np, <span class="string">&quot;bits-per-pixel&quot;</span>,</span><br><span class="line">			   &amp;bits_per_pixel);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get timings from device tree */</span></span><br><span class="line">  timings = of_get_display_timings(display_np);</span><br></pre></td></tr></table></figure>

<h2 id="使用参数配置LCD控制器"><a href="#使用参数配置LCD控制器" class="headerlink" title="使用参数配置LCD控制器"></a>使用参数配置LCD控制器</h2><p>根据芯片手册，一个一个设置寄存器：</p>
<ul>
<li>Framebuffer地址设置</li>
<li>Framebuffer中数据格式设置</li>
<li>LCD时序参数设置</li>
<li>LCD引脚极性设置</li>
</ul>
<p>注意：硬件参数，例如lcd控制器物理地址等，最好在设备树中指定，而不是写在代码中</p>
<h1 id="调试LCD驱动程序"><a href="#调试LCD驱动程序" class="headerlink" title="调试LCD驱动程序"></a>调试LCD驱动程序</h1><p>要做的事情</p>
<ul>
<li><p>去除内核自带的驱动程序</p>
</li>
<li><p>加入我们编写的驱动程序、设备树文件</p>
</li>
<li><p>重新编译内核、设备树</p>
</li>
<li><p>上机测试：使用编译出来的内核、设备树启动板子</p>
</li>
</ul>
<h1 id="单Buffer的缺点与改进方法"><a href="#单Buffer的缺点与改进方法" class="headerlink" title="单Buffer的缺点与改进方法"></a>单Buffer的缺点与改进方法</h1><h2 id="单buffer的缺点"><a href="#单buffer的缺点" class="headerlink" title="单buffer的缺点"></a>单buffer的缺点</h2><ul>
<li><p>如果APP速度很慢，可以看到它在LCD上缓慢绘制图案</p>
</li>
<li><p>即使APP速度很高，LCD控制器不断从Framebuffer中读取数据来显示，而APP不断把数据写入Framebuffer</p>
<ul>
<li><p>假设APP想把LCD显示为整屏幕的蓝色、红色</p>
</li>
<li><p>很大几率出现这种情况：</p>
<ul>
<li><p>LCD控制器读取Framebuffer数据，读到一半时，在LCD上显示了半屏幕的蓝色</p>
</li>
<li><p>这是APP非常高效地把整个Framebuffer的数据都改为了红色</p>
</li>
<li><p>LCD控制器继续读取数据，于是LCD上就会显示半屏幕蓝色、半屏幕红色</p>
</li>
<li><p>人眼就会感觉到屏幕闪烁、撕裂</p>
<img src="048_singble_buffer.png" style="zoom:53%;" /></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="使用多Buffer来改进"><a href="#使用多Buffer来改进" class="headerlink" title="使用多Buffer来改进"></a>使用多Buffer来改进</h2><p>上述两个缺点的根源是一致的：Framebuffer中的数据还没准备好整帧数据，就被LCD控制器使用了。</p>
<ul>
<li>使用双buffer甚至多buffer可以解决这个问题。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* 假设有2个Framebuffer：FB0、FB1</span><br><span class="line">* LCD控制器正在读取FB0</span><br><span class="line">* APP写FB1</span><br><span class="line">* 写好FB1后，让LCD控制器切换到FB1</span><br><span class="line">* APP写FB0</span><br><span class="line">* 写好FB0后，让LCD控制器切换到FB0	</span><br></pre></td></tr></table></figure>

<p>具体流程：</p>
<p><img src="049_drv_app_use_double_buff.png"></p>
<ul>
<li>驱动：分配多个buffer</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fb_info-&gt;fix.smem_len = SZ_32M;</span><br><span class="line">fbi-&gt;screen_base = dma_alloc_writecombine(fbi-&gt;device, <span class="comment">//fbi-&gt;screen_base虚拟地址</span></span><br><span class="line">				fbi-&gt;fix.smem_len,</span><br><span class="line">				(<span class="keyword">dma_addr_t</span> *)&amp;fbi-&gt;fix.smem_start, <span class="comment">//fix.smem_start物理地址</span></span><br><span class="line">				GFP_DMA | GFP_KERNEL);</span><br></pre></td></tr></table></figure>

<ul>
<li>驱动：保存buffer信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fb_info-&gt;fix.smem_len  <span class="comment">// 含有总buffer大小 </span></span><br><span class="line">fb_info-&gt;var           <span class="comment">// 含有单个buffer信息</span></span><br></pre></td></tr></table></figure>

<p>fb_info固定信息 fix：显存起始地址，大小</p>
<p>可变信息 var：x / y 分辨率</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*一般情况下*/</span> <span class="comment">/*分配了多个buffer，在y轴上叠加*/</span></span><br><span class="line">yres_virtual = yres *n; xres_virtual = xres; </span><br><span class="line"><span class="comment">/* 但驱动程序一开始并不使能多buffer </span></span><br><span class="line"><span class="comment">*  即yres_virtual = yres；</span></span><br><span class="line"><span class="comment">*  需要 set : yres_virtual = yres *n;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>APP : 读取buffer信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ioctl(fd_fb, FBIOGET_FSCREENINFO, &amp;fix);</span><br><span class="line">ioctl(fd_fb, FBIOGET_VSCREENINFO, &amp;var);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算是否支持多buffer，有多少个buffer</span></span><br><span class="line">screen_size = var.xres * var.yres * var.bits_per_pixel / <span class="number">8</span>;</span><br><span class="line">nBuffers = fix.smem_len / screen_size;</span><br></pre></td></tr></table></figure>

<ul>
<li>APP：使能多buffer</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var.yres_virtual = nBuffers * var.yres;</span><br><span class="line">ioctl(fd_fb, FBIOPUT_VSCREENINFO, &amp;var);</span><br></pre></td></tr></table></figure>

<ul>
<li>APP : 写buffer</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fb_base = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)mmap(<span class="literal">NULL</span> , fix.smem_len, PROT_READ | PROT_WRITE, MAP_SHARED, fd_fb, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get buffer */</span></span><br><span class="line">pNextBuffer =  fb_base + nNextBuffer * screen_size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set buffer */</span></span><br><span class="line">lcd_draw_screen(pNextBuffer, colors[i]);</span><br></pre></td></tr></table></figure>

<ul>
<li>APP : 切换buffer</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* switch buffer */</span></span><br><span class="line">var.yoffset = nNextBuffer * var.yres;</span><br><span class="line">ioctl(fd_fb, FBIOPAN_DISPLAY, &amp;var);</span><br></pre></td></tr></table></figure>

<ul>
<li>驱动：切换buffer</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fbmem.c</span></span><br><span class="line"><span class="function">fb_ioctl</span></span><br><span class="line"><span class="function">    do_fb_ioctl</span></span><br><span class="line"><span class="function">    	<span class="title">fb_pan_display</span><span class="params">(info, &amp;var)</span></span>;</span><br><span class="line">			err = info-&gt;fbops-&gt;fb_pan_display(var, info) <span class="comment">// 调用硬件相关的函数   </span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/13/uboot-uboot-dirver-model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="huahui">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huahui">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/13/uboot-uboot-dirver-model/" class="post-title-link" itemprop="url">U-BOOT DM驱动模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-13 15:20:50 / Modified: 15:23:44" itemprop="dateCreated datePublished" datetime="2022-02-13T15:20:50+08:00">2022-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/uboot/" itemprop="url" rel="index"><span itemprop="name">uboot</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="U-BOOT-DM驱动模型"><a href="#U-BOOT-DM驱动模型" class="headerlink" title="U-BOOT DM驱动模型"></a>U-BOOT DM驱动模型</h1><h2 id="Before-driver-model"><a href="#Before-driver-model" class="headerlink" title="Before driver model"></a>Before driver model</h2><ul>
<li>U-Boot has 10 useful design principles (e.g. small, fast, simple, portable)<ul>
<li>Huge community, over 1000 boards supported by the end of 2011</li>
<li>But Ad-hoc driver model started to bite</li>
</ul>
</li>
<li>Drivers were invoked through direct C calls<ul>
<li>i2c_read() is implemented by whichever driver is compiled in</li>
<li>CONFIG option select which I2C driver to use, clock speed, bus number, etc.</li>
</ul>
</li>
<li>Hard to scale<ul>
<li>Multiple I2C drivers must be munged into a single driver</li>
<li>Or an ad-hoc framework created to handle this requirements</li>
</ul>
</li>
<li>Configuration becoming unwieldy<ul>
<li>6000 CONFIG options at its peak</li>
<li>Kconfig conversion helps, but that’s still a lot of options</li>
</ul>
</li>
</ul>
<h3 id="dm-u-boot-pdf"><a href="#dm-u-boot-pdf" class="headerlink" title="dm-u-boot.pdf"></a>dm-u-boot.pdf</h3><p>U-Boot Mini Summit talk on driver model at ELCE 2014</p>
<p>Why driver model?</p>
<ul>
<li>Device init and access is ad-hoc<br>  – scsi_init(), mmc_init(), nand_init()</li>
<li>Many subsystems only allow one driver<br>  – But I have USB2 and USB3!</li>
<li>Communication between subsystems is tricky<br>  – How does an I2C expander or PMIC provide a GPIO?</li>
<li>Hard to answer simple questions<br>  – How many GPIOs? What is my serial console?</li>
<li>Board file functions provide the glue<br>  – What GPIO provides my MMC card detect?</li>
</ul>
<h2 id="Architecture-体系结构"><a href="#Architecture-体系结构" class="headerlink" title="Architecture 体系结构"></a>Architecture 体系结构</h2><p>DM (Driver Model)是 U-Boot 中的驱动框架。</p>
<ul>
<li><p>udevice 描述具体的某一个硬件设备。</p>
<ul>
<li>Instance of a driver</li>
<li>Created from some platform-specific information bound to a driver</li>
</ul>
</li>
<li><p>driver 是与这个设备匹配的驱动。</p>
<ul>
<li>Code to talk to a peripheral type (e.g. Ethernet switch, I2C controller, LCD)</li>
</ul>
</li>
<li><p>uclass 是同一类设备的抽象，提供管理同一类设备的抽象接口。</p>
<ul>
<li>A way of grouping devices which operate the same way</li>
</ul>
</li>
<li><p>Device tree and hierarchy</p>
<ul>
<li>设备树和层次结构</li>
</ul>
</li>
<li><p>Memory allocation</p>
</li>
<li><p>Sequence numbers</p>
<ul>
<li>序列号</li>
</ul>
</li>
</ul>
<p><img src="/2022/02/13/uboot-uboot-dirver-model/hierarchy.png"></p>
<p>像 Kernel 中的驱动三要素 device 、bus 、driver 一样，DM 也有自己的三要素：udevice、uclass、driver。以 serial 驱动为例：</p>
<p><img src="/2022/02/13/uboot-uboot-dirver-model/serial.png"></p>
<h2 id="Device-tree-configuration"><a href="#Device-tree-configuration" class="headerlink" title="Device tree configuration"></a>Device tree configuration</h2><p><img src="/2022/02/13/uboot-uboot-dirver-model/Device_tree_configuration.png"></p>
<h2 id="Device-sequence"><a href="#Device-sequence" class="headerlink" title="Device sequence"></a>Device sequence</h2><p><img src="/2022/02/13/uboot-uboot-dirver-model/Device_sequence.png"></p>
<h2 id="Automatic-memory-allocation"><a href="#Automatic-memory-allocation" class="headerlink" title="Automatic memory allocation"></a>Automatic memory allocation</h2><p><img src="/2022/02/13/uboot-uboot-dirver-model/Automatic_memory_allocation.png"></p>
<h2 id="Architecture-2"><a href="#Architecture-2" class="headerlink" title="Architecture 2"></a>Architecture 2</h2><ul>
<li>Binding and probing<ul>
<li>Bing creates the device but does not touch hardware</li>
<li>Probing activates the device ready for use</li>
</ul>
</li>
<li>Avoid private data structures<ul>
<li>Everything out in the open</li>
</ul>
</li>
<li>SPL support<ul>
<li>fdtgrep</li>
<li>Simple malloc()</li>
<li>Drop device removal code, warnings, etc.</li>
</ul>
</li>
</ul>
<h1 id="Driver-model-benefits-en"><a href="#Driver-model-benefits-en" class="headerlink" title="Driver model benefits (en)"></a>Driver model benefits (en)</h1><ul>
<li>Consistent view of devices regardless of their type</li>
<li>Multiple driver can be used with the same subsystem<ul>
<li>Drivers can be created which use others driver for their transport layer</li>
</ul>
</li>
<li>The lifecycle of a device is clear and consistent</li>
<li>Devices can be bound automatically<ul>
<li>Then probed automatically when used</li>
</ul>
</li>
<li>Supports device tree for configuration<ul>
<li>Thus sharing this with Linux and potentially other projects </li>
<li>Avoids recreating the same information again in a different format</li>
</ul>
</li>
</ul>
<h1 id="Driver-model-benefits-zh"><a href="#Driver-model-benefits-zh" class="headerlink" title="Driver model benefits (zh)"></a>Driver model benefits (zh)</h1><ul>
<li>一致的设备视图，无论其类型如何</li>
<li>同一个子系统可以使用多个驱动程序<ul>
<li>可以创建使用其他驱动程序作为传输层的驱动程序</li>
</ul>
</li>
<li>设备生命周期清晰一致</li>
<li>设备可自动绑定<ul>
<li>然后使用时自动探测</li>
</ul>
</li>
<li>支持设备树配置<ul>
<li>因此与 Linux 和潜在的其他项目共享这个</li>
<li>避免以不同的格式重新创建相同的信息</li>
</ul>
</li>
</ul>
<h1 id="DM-Limitations"><a href="#DM-Limitations" class="headerlink" title="DM Limitations"></a>DM Limitations</h1><ul>
<li>A driver can be in only one uclass<ul>
<li>Multi-function devices must use separate child devices</li>
</ul>
</li>
<li>Uses flattened device tree (FDT,即 device tree, dts)<ul>
<li>Driver model uses the device tree offset</li>
<li>Overlays and other mutations are not supported</li>
</ul>
</li>
</ul>
<h1 id="Comparisons-with-Linux"><a href="#Comparisons-with-Linux" class="headerlink" title="Comparisons with Linux"></a>Comparisons with Linux</h1><ul>
<li><p>Classes</p>
</li>
<li><p>Buses</p>
</li>
<li><p>Binding and probing </p>
</li>
<li><p>Memory allocation</p>
</li>
<li><p>Relocation and SPL //重定位 &amp; SPL</p>
</li>
<li><p>device visibility</p>
</li>
<li><p>Locking</p>
</li>
<li><p>Data structure size</p>
<ul>
<li>Core structure sizes are moderate<ul>
<li>struct uclass</li>
<li>struct udevice</li>
<li>struct driver</li>
</ul>
</li>
</ul>
</li>
<li><p>automatic memory allocation</p>
</li>
</ul>
<p><img src="/2022/02/13/uboot-uboot-dirver-model/Comparing_automatic_memory_allocation.png"></p>
<h2 id="A-few-examples"><a href="#A-few-examples" class="headerlink" title="A few examples"></a>A few examples</h2><h3 id="Example-1-Requesting-GPIOs"><a href="#Example-1-Requesting-GPIOs" class="headerlink" title="Example 1: Requesting GPIOs"></a>Example 1: Requesting GPIOs</h3><p><img src="/2022/02/13/uboot-uboot-dirver-model/Requesting_GPIOs.png"></p>
<h3 id="Example-2-Enabling-power"><a href="#Example-2-Enabling-power" class="headerlink" title="Example 2: Enabling power"></a>Example 2: Enabling power</h3><p><img src="/2022/02/13/uboot-uboot-dirver-model/Enabling_power.png"></p>
<h1 id="重要数据结构"><a href="#重要数据结构" class="headerlink" title="重要数据结构"></a>重要数据结构</h1><h2 id="udevice"><a href="#udevice" class="headerlink" title="udevice"></a>udevice</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct udevice - An instance of a driver</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This holds information about a device, which is a driver bound to a</span></span><br><span class="line"><span class="comment"> * particular port or peripheral (essentially a driver instance).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A device will come into existence through a &#x27;bind&#x27; call, either due to</span></span><br><span class="line"><span class="comment"> * a U_BOOT_DEVICE() macro (in which case platdata is non-NULL) or a node</span></span><br><span class="line"><span class="comment"> * in the device tree (in which case of_offset is &gt;= 0). In the latter case</span></span><br><span class="line"><span class="comment"> * we translate the device tree information into platdata in a function</span></span><br><span class="line"><span class="comment"> * implemented by the driver ofdata_to_platdata method (called just before the</span></span><br><span class="line"><span class="comment"> * probe method if the device has a device tree node.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * All three of platdata, priv and uclass_priv can be allocated by the</span></span><br><span class="line"><span class="comment"> * driver, or you can use the auto_alloc_size members of struct driver and</span></span><br><span class="line"><span class="comment"> * struct uclass_driver to have driver model do this automatically.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @driver: The driver used by this device</span></span><br><span class="line"><span class="comment"> * @name: Name of device, typically the FDT node name</span></span><br><span class="line"><span class="comment"> * @platdata: Configuration data for this device</span></span><br><span class="line"><span class="comment"> * @parent_platdata: The parent bus&#x27;s configuration data for this device</span></span><br><span class="line"><span class="comment"> * @uclass_platdata: The uclass&#x27;s configuration data for this device</span></span><br><span class="line"><span class="comment"> * @node: Reference to device tree node for this device</span></span><br><span class="line"><span class="comment"> * @driver_data: Driver data word for the entry that matched this device with</span></span><br><span class="line"><span class="comment"> *		its driver</span></span><br><span class="line"><span class="comment"> * @parent: Parent of this device, or NULL for the top level device</span></span><br><span class="line"><span class="comment"> * @priv: Private data for this device</span></span><br><span class="line"><span class="comment"> * @uclass: Pointer to uclass for this device</span></span><br><span class="line"><span class="comment"> * @uclass_priv: The uclass&#x27;s private data for this device</span></span><br><span class="line"><span class="comment"> * @parent_priv: The parent&#x27;s private data for this device</span></span><br><span class="line"><span class="comment"> * @uclass_node: Used by uclass to link its devices</span></span><br><span class="line"><span class="comment"> * @child_head: List of children of this device</span></span><br><span class="line"><span class="comment"> * @sibling_node: Next device in list of all devices</span></span><br><span class="line"><span class="comment"> * @flags: Flags for this device DM_FLAG_...</span></span><br><span class="line"><span class="comment"> * @req_seq: Requested sequence number for this device (-1 = any)</span></span><br><span class="line"><span class="comment"> * @seq: Allocated sequence number for this device (-1 = none). This is set up</span></span><br><span class="line"><span class="comment"> * when the device is probed and will be unique within the device&#x27;s uclass.</span></span><br><span class="line"><span class="comment"> * @devres_head: List of memory allocations associated with this device.</span></span><br><span class="line"><span class="comment"> *		When CONFIG_DEVRES is enabled, devm_kmalloc() and friends will</span></span><br><span class="line"><span class="comment"> *		add to this list. Memory so-allocated will be freed</span></span><br><span class="line"><span class="comment"> *		automatically when the device is removed / unbound</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">udevice</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">	<span class="keyword">void</span> *platdata;</span><br><span class="line">	<span class="keyword">void</span> *parent_platdata;</span><br><span class="line">	<span class="keyword">void</span> *uclass_platdata;</span><br><span class="line">	ofnode node;</span><br><span class="line">	ulong driver_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">udevice</span> *<span class="title">parent</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *priv;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclass</span> *<span class="title">uclass</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *uclass_priv;</span><br><span class="line">	<span class="keyword">void</span> *parent_priv;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">uclass_node</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">child_head</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling_node</span>;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> flags;</span><br><span class="line">	<span class="keyword">int</span> req_seq;</span><br><span class="line">	<span class="keyword">int</span> seq;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEVRES</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">devres_head</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有三种途径生成一个 udevice：</p>
<ol>
<li><p>dts 设备节点</p>
</li>
<li><p>UBOOTDEVICE(__name) 宏申明</p>
</li>
<li><p>调用 ‘bind’ API, device_bind_xxx</p>
</li>
</ol>
<h1 id="Device-Model-Start-up-sequence"><a href="#Device-Model-Start-up-sequence" class="headerlink" title="Device Model Start-up sequence"></a>Device Model Start-up sequence</h1><p>DM 启动顺序, core/root.c</p>
<ul>
<li>dm_init_and_scan():</li>
<li>dm_init()<ul>
<li>Creates an empty list of devices and uclasses</li>
<li>Binds and probes a root device</li>
</ul>
</li>
<li>dm_scan_platdata()<ul>
<li>Scans available platform data looking devices to be created</li>
<li>Platform data may only be used when memory constrains prohibit device tree</li>
</ul>
</li>
<li>dm_scan_fdt()<ul>
<li>Scan device tree and bind driver to nodes to create devices</li>
</ul>
</li>
</ul>
<p>根据当前 U-Boot 的编程哲学，基本大部分设备都是通过 dts 来描述，还有少部分设备因为特殊原因，可以通过 U_BOOT_DEVICE(_name) 宏申明。</p>
<h2 id="匹配过程"><a href="#匹配过程" class="headerlink" title="匹配过程"></a>匹配过程</h2><p>在UBoot DM 初始化阶段(initfdm 和 initrdm)，通过调用 dm_init_and_scan(boolpre_reloc_only) 根据名称 (UBOOT_DEVICE 中和 driver 的 name，或者 dts 和 driver 的 compatible) 匹配到对应的 driver，</p>
<p>然后调用 device_bind_common 函数生成 udevice，udevice 会和 driver 绑定，</p>
<p>并根据 driver 中的uclass id 找到对应的 uclass driver，并生成相应的 uclass， 并把该设备挂到 uclass 的设备节点之下。</p>
<p>最后调用 driver 的 bind 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">| -&gt; dm_init_and_scan</span><br><span class="line">    | -&gt; dm_init</span><br><span class="line">        | -&gt; INIT_LIST_HEAD <span class="comment">//创建 root 节点</span></span><br><span class="line">        | -&gt; device_bind_by_name()</span><br><span class="line">            | -&gt; lists_driver_lookup_name <span class="comment">//lists_driver_lookup_name(&quot;root_driver&quot;), This function returns a pointer a driver given its name.</span></span><br><span class="line">                | -&gt; ll_entry_start    <span class="comment">//Point to first entry of linker-generated array</span></span><br><span class="line">                | -&gt; ll_entry_count    <span class="comment">//Return the number of elements in linker-generated array</span></span><br><span class="line">                | -&gt; <span class="keyword">for</span> &#123; <span class="built_in">strcmp</span> &#125;    <span class="comment">//通过名字来遍历，得到匹配的 driver</span></span><br><span class="line">            | -&gt; device_bind_common</span><br><span class="line">                | -&gt; uclass_get</span><br><span class="line">                    | -&gt; uclass_find    <span class="comment">//Find uclass by uclass_id</span></span><br><span class="line">                | -&gt; list_add_tail    <span class="comment">//put dev into parent&#x27;s successor list</span></span><br><span class="line">                | -&gt; uclass_bind_device    </span><br><span class="line">        | -&gt; device_probe</span><br><span class="line">            | -&gt; </span><br><span class="line">    | -&gt; dm_scan_platdata</span><br><span class="line">    | -&gt; dm_extended_scan_fdt</span><br><span class="line">    | -&gt; dm_scan_other</span><br></pre></td></tr></table></figure>



<p>还有部分特殊的驱动，他们并不存在实际意义上的设备，比如 MMC 子系统中的 mmcblk 驱动，</p>
<p>该驱动主要是把所有的 mmc 设备注册到更上一层的 blk 子系统中，向 blk 层提供操作 mmc 设备的 blkops，向下通过mmc uclass 提供的统一接口控制 mmc 设备。显然，这个驱动位于抽象层，它不和具体的硬件设备直接交互，并不适合用一个 dts(dts 是用来描述具体的硬件信息的) 节点或者 UBOOTDEVICE(_name) 宏来为这个驱动显示的申明设备。这种情形下一般通过主动调用 device_bind_xxx 系列 API 来完成驱动和设备已经更上一层 uclass 之间的 bind。</p>
<p><img src="/2022/02/13/uboot-uboot-dirver-model/NO1.jpeg"></p>
<p>A：生成 udevice。<br>B：绑定 udevice 和 driver。<br>C：把设备挂到 uclass 的dev_head 链表下。<br>D：调用设备驱动的 bind 接口。</p>
<h1 id="uclass"><a href="#uclass" class="headerlink" title="uclass"></a>uclass</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct uclass - a U-Boot drive class, collecting together similar drivers</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A uclass provides an interface to a particular function, which is</span></span><br><span class="line"><span class="comment"> * implemented by one or more drivers. Every driver belongs to a uclass even</span></span><br><span class="line"><span class="comment"> * if it is the only driver in that uclass. An example uclass is GPIO, which</span></span><br><span class="line"><span class="comment"> * provides the ability to change read inputs, set and clear outputs, etc.</span></span><br><span class="line"><span class="comment"> * There may be drivers for on-chip SoC GPIO banks, I2C GPIO expanders and</span></span><br><span class="line"><span class="comment"> * PMIC IO lines, all made available in a unified way through the uclass.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @priv: Private data for this uclass</span></span><br><span class="line"><span class="comment"> * @uc_drv: The driver for the uclass itself, not to be confused with a</span></span><br><span class="line"><span class="comment"> * &#x27;struct driver&#x27;</span></span><br><span class="line"><span class="comment"> * @dev_head: List of devices in this uclass (devices are attached to their</span></span><br><span class="line"><span class="comment"> * uclass when their bind method is called)</span></span><br><span class="line"><span class="comment"> * @sibling_node: Next uclass in the linked list of uclasses</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uclass</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span> *priv;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uclass_driver</span> *<span class="title">uc_drv</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dev_head</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling_node</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里主要的成员是 uclassdriver 和 devhead 链表。</p>
<ul>
<li>dev_head 是一个链表头， 用来链接该类下的所有设备。可以通过 uclass_foreach_dev(dev,uc) 遍历该class 下的所有设备。</li>
<li>uclass_driver 是针对某一类设备提供的通用<strong>操作接口</strong>，然后通过 udevice-&gt;driver-&gt;ops 操作到具体的硬件设备。<br>uclassdriver 通过 UCLASSDRIVER(name) 宏申明， 在 device_bind_common 中根据 设备对应的驱动 driver 中的 uclass id 找到 uclassdriver，并生成相应的 uclass， 并把设备挂到该 uclass 的设备节点 dev_head 下。</li>
</ul>
<h2 id="以-pwm-backlight-为例："><a href="#以-pwm-backlight-为例：" class="headerlink" title="以 pwm backlight 为例："></a>以 pwm backlight 为例：</h2><p><img src="/2022/02/13/uboot-uboot-dirver-model/NO2.jpeg"></p>
<p>通过 UBOOTDRIVER 的 id 可以看出，该设备(pwm backlight)驱动属于 UCLASSPANELBACKLIGHT 类。</p>
<p><img src="/2022/02/13/uboot-uboot-dirver-model/NO3.jpeg"></p>
<p>这里定义了 backlight 的 UCLASS_DRIVER。该 uclass driver 提供了<code> backlight_enable(struct udevice*dev) 和 backlight_set_brightness(struct udevice*dev,intpercent)</code> 两个通用的 API 供应用调用，可以看到他们都需要传递对应设备的 udevice ，然后通过 backlight_get_ops(dev) 拿到对该设备的操作接口。</p>
<p>#define backlight_get_ops(dev)  ((struct backlight_ops *)(dev)-&gt;driver-&gt;ops)</p>
<h1 id="driver"><a href="#driver" class="headerlink" title="driver"></a>driver</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct driver - A driver for a feature or peripheral</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This holds methods for setting up a new device, and also removing it.</span></span><br><span class="line"><span class="comment"> * The device needs information to set itself up - this is provided either</span></span><br><span class="line"><span class="comment"> * by platdata or a device tree node (which we find by looking up</span></span><br><span class="line"><span class="comment"> * matching compatible strings with of_match).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Drivers all belong to a uclass, representing a class of devices of the</span></span><br><span class="line"><span class="comment"> * same type. Common elements of the drivers can be implemented in the uclass,</span></span><br><span class="line"><span class="comment"> * or the uclass can provide a consistent interface to the drivers within</span></span><br><span class="line"><span class="comment"> * it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @name: Device name</span></span><br><span class="line"><span class="comment"> * @id: Identifies the uclass we belong to</span></span><br><span class="line"><span class="comment"> * @of_match: List of compatible strings to match, and any identifying data</span></span><br><span class="line"><span class="comment"> * for each.</span></span><br><span class="line"><span class="comment"> * @bind: Called to bind a device to its driver</span></span><br><span class="line"><span class="comment"> * @probe: Called to probe a device, i.e. activate it</span></span><br><span class="line"><span class="comment"> * @remove: Called to remove a device, i.e. de-activate it</span></span><br><span class="line"><span class="comment"> * @unbind: Called to unbind a device from its driver</span></span><br><span class="line"><span class="comment"> * @ofdata_to_platdata: Called before probe to decode device tree data</span></span><br><span class="line"><span class="comment"> * @child_post_bind: Called after a new child has been bound</span></span><br><span class="line"><span class="comment"> * @child_pre_probe: Called before a child device is probed. The device has</span></span><br><span class="line"><span class="comment"> * memory allocated but it has not yet been probed.</span></span><br><span class="line"><span class="comment"> * @child_post_remove: Called after a child device is removed. The device</span></span><br><span class="line"><span class="comment"> * has memory allocated but its device_remove() method has been called.</span></span><br><span class="line"><span class="comment"> * @priv_auto_alloc_size: If non-zero this is the size of the private data</span></span><br><span class="line"><span class="comment"> * to be allocated in the device&#x27;s -&gt;priv pointer. If zero, then the driver</span></span><br><span class="line"><span class="comment"> * is responsible for allocating any data required.</span></span><br><span class="line"><span class="comment"> * @platdata_auto_alloc_size: If non-zero this is the size of the</span></span><br><span class="line"><span class="comment"> * platform data to be allocated in the device&#x27;s -&gt;platdata pointer.</span></span><br><span class="line"><span class="comment"> * This is typically only useful for device-tree-aware drivers (those with</span></span><br><span class="line"><span class="comment"> * an of_match), since drivers which use platdata will have the data</span></span><br><span class="line"><span class="comment"> * provided in the U_BOOT_DEVICE() instantiation.</span></span><br><span class="line"><span class="comment"> * @per_child_auto_alloc_size: Each device can hold private data owned by</span></span><br><span class="line"><span class="comment"> * its parent. If required this will be automatically allocated if this</span></span><br><span class="line"><span class="comment"> * value is non-zero.</span></span><br><span class="line"><span class="comment"> * @per_child_platdata_auto_alloc_size: A bus likes to store information about</span></span><br><span class="line"><span class="comment"> * its children. If non-zero this is the size of this data, to be allocated</span></span><br><span class="line"><span class="comment"> * in the child&#x27;s parent_platdata pointer.</span></span><br><span class="line"><span class="comment"> * @ops: Driver-specific operations. This is typically a list of function</span></span><br><span class="line"><span class="comment"> * pointers defined by the driver, to implement driver functions required by</span></span><br><span class="line"><span class="comment"> * the uclass.</span></span><br><span class="line"><span class="comment"> * @flags: driver flags - see DM_FLAGS_...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">driver</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> *name;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">uclass_id</span> <span class="title">id</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">udevice_id</span> *<span class="title">of_match</span>;</span></span><br><span class="line">	<span class="keyword">int</span> (*bind)(struct udevice *dev);</span><br><span class="line">	<span class="keyword">int</span> (*probe)(struct udevice *dev);</span><br><span class="line">	<span class="keyword">int</span> (*remove)(struct udevice *dev);</span><br><span class="line">	<span class="keyword">int</span> (*unbind)(struct udevice *dev);</span><br><span class="line">	<span class="keyword">int</span> (*ofdata_to_platdata)(struct udevice *dev);</span><br><span class="line">	<span class="keyword">int</span> (*child_post_bind)(struct udevice *dev);</span><br><span class="line">	<span class="keyword">int</span> (*child_pre_probe)(struct udevice *dev);</span><br><span class="line">	<span class="keyword">int</span> (*child_post_remove)(struct udevice *dev);</span><br><span class="line">	<span class="keyword">int</span> priv_auto_alloc_size;</span><br><span class="line">	<span class="keyword">int</span> platdata_auto_alloc_size;</span><br><span class="line">	<span class="keyword">int</span> per_child_auto_alloc_size;</span><br><span class="line">	<span class="keyword">int</span> per_child_platdata_auto_alloc_size;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *ops;	<span class="comment">/* driver-specific operations */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过 UBOOTDRIVER(__name) 宏声明。如果 driver 实现了 bind 接口，该bind 将在 device_bind_common 中 device 和 driver 匹配上后被调用, 而且在 device_bind_common 中会完成 udevice 和 driver 的绑定。</p>
<p>driver 一般都有对应的 probe 接口，通过 device_probe(structudevice*dev) 调用，需要注意的是driver 的 bind 接口调用的比 probe 接口早， 大部分在 dm_init_and_scan 中就被调用了。</p>
<p>driver 一般会提供 ops 操作接口，供上一层调用。</p>
<p>需要说明的是，driver 一般都不需要把自己注册到 uclass 中，而是在 device_bind _common 阶段实现driver 、uclass、device 三者的对接，然后 uclass 层通过 udevice-&gt;driver-&gt;ops 获取对应 driver 的操作接口。</p>
<h1 id="设备驱动的使用"><a href="#设备驱动的使用" class="headerlink" title="设备驱动的使用"></a>设备驱动的使用</h1><p>一般应用层的代码要使用某个设备的时候，首先需要通过 uclass_get_device_xxx 系列 API 拿到该设备的 udevice， 然后通过该设备的 uclass 提供的 API 操作该设备。</p>
<p>uclass_get_device_xxx 拿到该设备的 udevice 后会调用该设备的 probe 接口。</p>
<p>以前面提到的 pwm backlight 为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * drivers/video/simple_panel.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">udevice</span> *<span class="title">bldev</span>;</span></span><br><span class="line">uclass_get_device_by_phandle(UCLASS_PANEL_BACKLIGHT, dev, <span class="string">&quot;backlight&quot;</span>, &amp;bldev);</span><br><span class="line">backlight_enable(bldev);</span><br><span class="line">backlight_set_brightness(bldev, percent);</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/12/Linux%E9%A9%B1%E5%8A%A8-dma-buf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="huahui">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huahui">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/12/Linux%E9%A9%B1%E5%8A%A8-dma-buf/" class="post-title-link" itemprop="url">Dma_buf</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-02-12 23:17:28" itemprop="dateCreated datePublished" datetime="2022-02-12T23:17:28+08:00">2022-02-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-02-13 15:19:33" itemprop="dateModified" datetime="2022-02-13T15:19:33+08:00">2022-02-13</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="dma-buf"><a href="#dma-buf" class="headerlink" title="dma-buf"></a>dma-buf</h1><p>dma-buf的出现是为了解决各驱动之间buffer共享的问题，因此它本质上是<strong>buffer和file的结合</strong>，即它既是一块物理连续的buffer，<br>也是一个linux file。buffer是内容，file是媒介，通过file这个媒介来实现buffer的共享。</p>
<p>一个典型的dma-buf的应用框架如下：<br><img src="/2022/02/12/Linux%E9%A9%B1%E5%8A%A8-dma-buf/dma-buf1.png"></p>
<p>通常，分配buffer的模块称为<code>exportor</code>，使用该buffer的模块称为<code>importor</code>或<code>user</code>。</p>
<p>一个最简单的dma-buf驱动包含以下元素：</p>
<ol>
<li>dma_buf_ops</li>
<li>DEFINE_DMA_BUF_EXPORT_INFO</li>
<li>dma_buf_export()</li>
</ol>
<h1 id="dma-buf-不仅仅只能用于DMA硬件访问"><a href="#dma-buf-不仅仅只能用于DMA硬件访问" class="headerlink" title="dma-buf 不仅仅只能用于DMA硬件访问"></a>dma-buf 不仅仅只能用于DMA硬件访问</h1><p><strong>dma-buf本质是buffer和file的结合</strong>，任然是一块buffer，不仅能用于DMA硬件访问，也同样适应CPU软件访问，这也是dma-buf在内核中<br>广受欢迎的一个重要原因。经过他的API都带有<em>dma</em>字样。</p>
<h1 id="dma-buf既能分配物理连续的buffer，也可以是离散的buffer"><a href="#dma-buf既能分配物理连续的buffer，也可以是离散的buffer" class="headerlink" title="dma-buf既能分配物理连续的buffer，也可以是离散的buffer"></a>dma-buf既能分配物理连续的buffer，也可以是离散的buffer</h1><p>分配那种beffer最终取决与exportor驱动采用何种方式来分配buffer。例如：采用内核中最常见的<code>kmalloc()</code>函数来分配dma-buf,这块buffer<br>自然就是物理连续的。</p>
<h1 id="CPU-Access"><a href="#CPU-Access" class="headerlink" title="CPU Access"></a>CPU Access</h1><p>从 linux-3.4 开始，dma-buf 引入了 CPU 操作接口，使得开发人员可以在内核空间里直接使用 CPU 来访问 dma-buf 的物理内存。</p>
<p>如下 dma-buf API 实现了 CPU 在内核空间对 dma-buf 内存的访问：</p>
<ul>
<li>dma_buf_kmap()</li>
<li>dma_buf_kmap_atomic()</li>
<li>dma_buf_vmap()</li>
</ul>
<p>（它们的反向操作分别对应各自的 unmap 接口）<br>通过 <code>dma_buf_kmap() / dma_buf_vmap()</code> 操作，就可以把实际的物理内存，映射到 kernel 空间，并转化成 CPU 可以连续访问的虚拟地址<br>方便后续软件直接读写这块物理内存。因此，无论这块 buffer 在物理上是否连续，在经过 kmap / vmap 映射后的虚拟地址一定是连续的。</p>
<p>上述的3个接口分别和 linux 内存管理子系统（MM）中的 <code>kmap()、 kmap_atomic()</code> 和 <code>vmap()</code> 函数一一对应，三者的区别如下：<br>|函数|    说明|<br>|–|–|<br>|kmap()|    一次只能映射1个page，可能会睡眠，只能在进程上下文中调用|<br>|kmap_atomic()|    一次只能映射1个page，不会睡眠，可在中断上下文中调用|<br>|vmap()|    一次可以映射多个pages，且这些pages物理上可以不连续，只能在进程上下文中调用|</p>
<blockquote>
<p>  从 linux-4.19 开始，dma_buf_kmap_atomic() 不再被支持。<br>  dma_buf_ops 中的 map / map_atomic 接口名，其实原本就叫 kmap / kmap_atomic，只是后来发现与 highmem.h 中的宏定义重名了，<br>  了避免开发人员在自己的驱动中引用 highmem.h 而带来的命名冲突问题，于是去掉了前面的“k”字。</p>
</blockquote>
<h1 id="DMA-Access"><a href="#DMA-Access" class="headerlink" title="DMA Access"></a>DMA Access</h1><p>dma-buf 允许CPU 在 kernel 空间访问 dma-buf 物理内存，但通常这种操作方法在内核中出现的频率并不高，因为 dma-buf 设计之初<br>就是为满足那些大内存访问需求的硬件而设计的，如GPU/DPU。在这种场景下，如果使用CPU直接去访问 memory，那么性能会大大降低。<br>因此，dma-buf 在内核中出现频率最高的还是</p>
<ul>
<li>dma_buf_attach() </li>
<li>dma_buf_map_attachment() </li>
</ul>
<p>这两个接口是dma-buf提供给DMA硬件访问的主要API，而且两者有严格的调用顺序，必须先<code>attach</code>，再<code>map_attachment</code>，因为后者的参数<br>是由前者提供的，所以通常这两个接口形影不离。<br>两个 API 相对应的反向操作接口为： <code>dma_buf_dettach()</code> 和 <code>dma_buf_unmap_attachment()</code></p>
<h1 id="sg-table"><a href="#sg-table" class="headerlink" title="sg_table"></a>sg_table</h1><p><code>sg_table</code> 是 dma-buf 供 DMA 硬件访问的终极目标，也是 DMA 硬件访问离散 memory 的唯一途径。</p>
<p>sg_table 本质上是由一块块单个物理连续的 buffer 所组成的链表，但是这个链表整体上看却是离散的，<br>因此它可以很好的描述从<code>高端内存</code>上分配出的离散 buffer。当然，它同样可以用来描述从<code>低端内存</code>上分配出的物理连续 buffer。<br>如下图所示：<br><img src="/2022/02/12/Linux%E9%A9%B1%E5%8A%A8-dma-buf/dma-buf2.png"></p>
<p>sg_table代表着整个链表，而它的每一个链表项则由<code>scatterlist</code>来表示。因此，1个<code>scatterlist</code>也就对应着一块<code>物理连续</code>的 buffer。<br>通过如下接口来获取一个<code>scatterlist</code>对应 buffer 的物理地址和长度：</p>
<ul>
<li>sg_dma_address(sgl)</li>
<li>sg_dma_len(sgl)</li>
</ul>
<p>有了 buffer 的物理地址和长度，可以将这两个参数配置到 DMA 硬件寄存器中，这样就可以实现 DMA 硬件对这一小块 buffer 的访问。<br>如果需要访问整块离散 buffer ，可通过使用 for 循环，不断的解析<code>scatterlist</code>，不断的配置 DMA 硬件寄存器。</p>
<blockquote>
<p>对于现代多媒体硬件来说，IOMMU 的出现，解决了程序员编写 for 循环的烦恼。因为在 for 循环中，每次配置完 DMA 硬件寄存器后，<br>都需要等待本次 DMA 传输完毕，然后才能进行下一次循环，这大大降低了软件的执行效率。而 IOMMU 的功能就是用来解析 sg_table 的，<br>它会将 sg_table 内部一个个离散的小 buffer 映射到自己内部的设备地址空间，使得这整块 buffer 在自己内部的设备地址空间上是连续的<br>这样，在访问离散 buffer 的时候，只需要将 IOMMU 映射后的设备地址（与 MMU 映射后的 CPU 虚拟地址不是同一概念）和整块 buffer 的<br>size 配置到 DMA 硬件寄存器中即可，中途无需再多次配置，便完成了 DMA 硬件对整块离散 buffer 的访问，大大的提高了软件的效率。</p>
</blockquote>
<h2 id="dma-buf-attach"><a href="#dma-buf-attach" class="headerlink" title="dma_buf_attach()"></a>dma_buf_attach()</h2><p>该函数实际上是<code>dma-buf attach device</code>的缩写，用于建立一个<code>device</code>与<code>dma-buf</code>的链接关系，这个连接关系被存放在新创建的<br><code>dma_buf_attachment</code>对象中，供后续调用<code>dma_buf_map_attachment()</code>使用。</p>
<p>该函数对应<code>dma_buf_ops</code>中的回调接口，如果device对后续的map_attachment操作没有特殊要求，可以不实现。</p>
<h2 id="dma-buf-map-attachment"><a href="#dma-buf-map-attachment" class="headerlink" title="dma_buf_map_attachment()"></a>dma_buf_map_attachment()</h2><p>该函数实际上是<code>dma-buf map attachment into sg_table</code>的缩写，主要完成2件事：</p>
<ul>
<li>生成 sg_table</li>
<li>同步 Cache</li>
</ul>
<p>选择返回<code>sg_table</code>而不是物理地址，是为了兼容所有DMA硬件（带或不带IOMMU），因为<code>sg_table</code>既可以表示连续物理内存，也可以表示<br>非连续物理内存。</p>
<p>同步<code>Cache</code>是为了防止该buffer事先被CPU填充过，数据暂存在Cache中而非DDR上，导致DMA访问的不是最新的有效数据。<br>通过刷cache避免此类问题。同样的，在DMA访问内存结束后，需要将Cache设置为无效（no-Cache），以便后续CPU直接从DDR上读取数据。<br>通常使用如下流式DMA映射接口来完成Cache的同步：</p>
<ul>
<li>dma_map_single() / dma_unmap_single()</li>
<li>dma_map_page() / dma_unmap_page()</li>
<li>dma_map_sg() / dma_unmap_sg()</li>
</ul>
<p><code>dma_buf_map_attachment()</code> 对应 <code>dma_buf_ops</code> 中的 <code>map_dma_buf</code> 回调接口，<br>该回调接口（包括 unmap_dma_buf 在内）被强制要求实现。</p>
<blockquote>
<p>延伸：<code>dma_buf_ops</code>中部分回调被要求强制实现。</p>
</blockquote>
<h2 id="为什么要attach操作"><a href="#为什么要attach操作" class="headerlink" title="为什么要attach操作"></a>为什么要attach操作</h2><p>同一个 dma-buf 可能会被多个 DMA 硬件访问，而每个 DMA 硬件可能会因为自身硬件能力的限制，对这块 buffer 有自己特殊的要求。<br>比如硬件 A 的寻址能力只有0x0 ~ 0x10000000，而硬件 B 的寻址能力为 0x0 ~ 0x80000000，那么在分配 dma-buf 的物理内存时，<br>就必须以硬件 A 的能力为标准进行分配，这样硬件 A 和 B 都可以访问这段内存。<br>否则，如果只满足 B 的需求，那么 A 可能就无法访问超出 0x10000000 地址以外的内存空间，道理其实类似于木桶理论。<br>因此，attach 操作可以让 exporter 驱动根据不同的 device 硬件能力，来分配最合适的物理内存。</p>
<blockquote>
<p>通过设置 device-&gt;dma_params 参数，来告知 exporter 驱动该 DMA 硬件的能力限制。</p>
</blockquote>
<h2 id="何时分配内存"><a href="#何时分配内存" class="headerlink" title="何时分配内存"></a>何时分配内存</h2><p>既可以在 export 阶段分配，也可以在 map_attachment 阶段分配，甚至可以在两个阶段都分配，这通常由 DMA 硬件能力来决定。</p>
<p>首先，驱动人员需要统计当前系统中都有哪些 DMA 硬件要访问 dma-buf；<br>然后，根据不同的 DMA 硬件能力，来决定在何时以及如何分配物理内存。</p>
<p>通常的策略如下（假设只有 A、B 两个硬件需要访问 dma-buf ）：</p>
<ul>
<li>如果硬件 A 和 B 的寻址空间有交集，则在 export 阶段进行内存分配，分配时以 A / B 的交集为准；</li>
<li>如果硬件 A 和 B 的寻址空间没有交集，则只能在 map attachment 阶段分配内存。</li>
</ul>
<p>对于第二种策略，因为 A 和 B 的寻址空间没有交集（即完全独立），所以它们实际上是无法实现内存共享的。<br>此时的解决办法是： A 和 B 在 map attachment 阶段，都分配各自的物理内存，然后通过 CPU 或 通用DMA 硬件，<br>将 A 的 buffer 内容拷贝到 B 的 buffer 中去，以此来间接的实现 buffer “共享”。</p>
<p>另外还有一种策略，就是不管三七二十一，先在 export 阶段分配好内存，然后在首次 map attachment 阶段<br>通过 dma_buf-&gt;attachments 链表，与所有 device 的能力进行一一比对，如果满足条件则直接返回 sg_table；<br>如果不满足条件，则重新分配符合所有 device 要求的物理内存，再返回新的 sg_table。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>sg_table 是 DMA 硬件操作的关键；</li>
<li>attach 的目的是为了让后续 map attachment 操作更灵活；</li>
<li>map attachment 主要完成两件事：生成 sg_table 和 Cache 同步；</li>
<li>DMA 的硬件能力决定了 dma-buf 物理内存的分配时机；</li>
</ol>
<h1 id="在user-space-访问-dma-buf"><a href="#在user-space-访问-dma-buf" class="headerlink" title="在user space 访问 dma-buf"></a>在user space 访问 dma-buf</h1><p>user space 访问 dma-buf 也属于 CPU Access 的一种。</p>
<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p>为了方便应用程序能直接在用户空间读写 dma-buf 的内存，<code>dma_buf_ops</code>为我们提供了一个<code>mmap</code>回调接口，<br>可以把 dma-buf 的物理内存直接映射到用户空间，这样应用程序就可以像访问普通文件那样访问 dma-buf 的物理内存了。</p>
<blockquote>
<p>在 Linux 设备驱动中，大多数驱动的 mmap 操作接口都是通过调用<code>remap_pfn_range()</code>函数来实现的，dma-buf 也不例外</p>
</blockquote>
<p>除了<code>dma_buf_ops</code>提供的 mmap 回调接口外，dma-buf 还为我们提供了<code>dma_buf_mmap()</code>内核 API，<br>使得我们可以在其他设备驱动中就地取材，直接引用 dma-buf 的 mmap 实现，以此来间接的实现设备驱动的 mmap 文件操作接口</p>
<p><img src="/2022/02/12/Linux%E9%A9%B1%E5%8A%A8-dma-buf/dma-buf3.png"></p>
<h1 id="file"><a href="#file" class="headerlink" title="file"></a>file</h1><p>dma-buf 本质上是 buffer 与 file 的结合，既然与file有关系，就涉及到<code>fd</code></p>
<h2 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h2><p>如下内核 API 实现了 dma-buf 与 fd 之间的相互转换：</p>
<ul>
<li>dma_buf_fd()：dma-buf –&gt; new fd</li>
<li>dma_buf_get()：fd –&gt; dma-buf</li>
</ul>
<p>通常使用方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = dma_buf_fd(dmabuf);</span><br><span class="line">dmabuf = dma_buf_get(fd);</span><br></pre></td></tr></table></figure>

<h2 id="get-put"><a href="#get-put" class="headerlink" title="get / put"></a>get / put</h2><p>只要是文件，内部都会有一个引用计数(f_count)。当<code>dma_buf_export()</code>函数创建dma-buf时，该引用计数被初始化为1；当这个引用计数为0时，则会自动触发<br><code>dma_buf_ops</code>的<code>release</code>回调接口，并释放<code>dma-buf</code>对象。</p>
<p>linux内核中操作file引用计数的常用函数为<code>fget()</code>和<code>fput()</code>，而dma-buf又在此基础上进行了封装，如下：</p>
<ul>
<li>get_dma_buf()</li>
<li>dma_buf_get()</li>
<li>dma_buf_put()</li>
</ul>
<p>其中区别如下：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>区别</th>
</tr>
</thead>
<tbody><tr>
<td>get_dma_buf()</td>
<td>仅引用计数加1</td>
</tr>
<tr>
<td>dma_buf_get()</td>
<td>引用计数加1，并将 fd 转换成 dma_buf 指针</td>
</tr>
<tr>
<td>dma_buf_put()</td>
<td>引用计数减1</td>
</tr>
<tr>
<td>dma_buf_fd()</td>
<td>引用计数不变，仅创建 fd</td>
</tr>
</tbody></table>
<h2 id="release"><a href="#release" class="headerlink" title="release"></a>release</h2><p>通常 release 回调接口用来释放 dma-buf 所对应的物理 buffer。<br>凡是所有和该 dma-buf 相关的私有数据也都应该在这里被 free 掉。</p>
<p>前面说过，只有当 dma-buf 的引用计数递减到0时，才会触发 release 回调接口。因此</p>
<ul>
<li>如果不想正在使用的 buffer 被突然释放，请提前 get；</li>
<li>如果想在 kernel space 释放 buffer，请使劲 put；</li>
<li>如果想从 user space 释放 buffer，请尝试 close；</li>
</ul>
<p><strong>这就是为什么在内核设备驱动中，我们会看到那么多 dma-buf get 和 put 的身影</strong></p>
<blockquote>
<p>如果没有任何程序来修改该 dma-buf 的引用计数，自始自终都保持为1，会无法执行 release 接口<br>这会导致 buffer 无法被释放，造成<strong>内存泄漏</strong></p>
</blockquote>
<h2 id="跨进程-fd"><a href="#跨进程-fd" class="headerlink" title="跨进程 fd"></a>跨进程 fd</h2><p>做 Linux 应用开发的同事都知道，fd 属于进程资源，它的作用域只在单个进程空间范围内有效，即同样的 fd 值，<br>在进程 A 和 进程 B 中所指向的文件是不同的。因此 fd 是不能在多个进程之间共享的，<br>也就是说 dma_buf_fd() 与 dma_buf_get() 只能是在同一进程中调用。</p>
<p>fd 并不是完全不能在多进程中共享，而是需要采用特殊的方式进行传递。<br>在 linux 系统中，最常用的做法就是通过 socket 来实现 fd 的传递。而在 Android 系统中，则是通过 Binder 来实现的。<br>需要注意的是，传递后 fd 的值可能会发生变化，但是它们所指向的文件都是同一文件。<br>总之，有了 Binder，dma_buf_fd() 和 dma_buf_get() 就可以不用严格限制在同一进程中使用了。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>为什么需要fd?</p>
<ol>
<li><p>方便应用程序直接在 user space 访问该 buffer，通过 mmap；</p>
</li>
<li><p>方便该 buffer 在各个驱动模块之间流转，而无需拷贝；</p>
</li>
<li><p>降低了各驱动之间的耦合度。</p>
</li>
</ol>
</li>
<li><p>如何实现 fd 跨进程共享？ Binder!</p>
</li>
<li><p>get / put 将影响 dma-buf 的内存释放</p>
</li>
</ul>
<h2 id="Cache-一致性"><a href="#Cache-一致性" class="headerlink" title="Cache 一致性"></a>Cache 一致性</h2><p>dma-buf 有以下接口用于 Cache 同步：</p>
<ul>
<li>begin_cpu_access </li>
<li>end_cpu_access</li>
</ul>
<p>CPU 与 DMA 访问 DDR 之间的区别：<br><img src="/2022/02/12/Linux%E9%A9%B1%E5%8A%A8-dma-buf/dma-buf4.png"></p>
<p>CPU 在访问内存时是要经过 Cache 的，而 DMA 外设则是直接和 DDR 打交道，因此这就存在 Cache 一致性的问题了<br>即 Cache 里面的数据是否和 DDR 里面的数据保持一致。<br>比如 DMA 外设早已将 DDR 中的数据改写了，而 CPU 却浑然不知，仍然在访问 Cache 里面暂存的旧数据。</p>
<p>所以 Cache 一致性问题，只有在 CPU 参与访问的情况下才会发生。<br>如果一个 dma-buf 自始自终都只被一个硬件访问（要么CPU，要么DMA），那么 Cache 一致性问题就不会存在。</p>
<blockquote>
<p>当然，如果一个 dma-buf 所对应的物理内存本身就是 Uncache 的（也叫一致性内存），<br>或者说该 buffer 在被分配时是以 coherent 方式分配的，<br>这种情况下，CPU 是不经过 cache 而直接访问 DDR 的，自然 Cache 一致性问题也就不存在了。</p>
</blockquote>
<h2 id="为什么需要-begin-end-操作？"><a href="#为什么需要-begin-end-操作？" class="headerlink" title="为什么需要 begin / end 操作？"></a>为什么需要 begin / end 操作？</h2><p>dma-buf使用流式 DMA 映射接口来实现 Cache 同步操作。这类接口的特点就是 Cache 同步只是<strong>一次性</strong>的，<br>即在 dma map 的时候执行一次 Cache Flush 操作，在 dma unmap 的时候执行一次 Cache Invalidate 操作，<br>而这<strong>中间的过程是不保证 Cache 和 DDR 上数据的一致性的</strong>。</p>
<p>因此如果 CPU 在 dma map 和 unmap 之间又去访问了这块内存，<br>那么有可能 CPU 访问到的数据就只是暂存在 Cache 中的旧数据，这就带来了问题。</p>
<p>那么什么情况下会出现 CPU 在 dma map 和 unmap 期间又去访问这块内存呢？<br>一般不会出现 DMA 硬件正在传输过程中突然 CPU 发起访问的情况，<br>而更多的是在 DMA 硬件发起传输之前，或 DMA 硬件传输完成之后，<br>并且仍然处于 dma map 和 unmap 操作之间的时候，CPU 对这段内存发起了访问。</p>
<p>针对这种情况，就需要在 CPU 访问内存前，先将 DDR 数据同步到 Cache 中（Invalidate）；<br>在 CPU 访问结束后，将 Cache 中的数据回写到 DDR 上（Flush），以便 DMA 能获取到 CPU 更新后的数据。<br>这也就是 dma-buf 给我们预留 {begin,end}_cpu_access 的原因。</p>
<h2 id="Kernel-API"><a href="#Kernel-API" class="headerlink" title="Kernel API"></a>Kernel API</h2><p>dma-buf 为我们提供了如下内核 API，用来在 dma map 期间发起 CPU 访问操作：</p>
<ul>
<li>dma_buf_begin_cpu_access()</li>
<li>dma_buf_end_cpu_access()</li>
</ul>
<p>它们分别对应 <code>dma_buf_ops</code> 中的 <code>begin_cpu_access</code> 和 <code>end_cpu_access</code> 回调接口。</p>
<p>通常在驱动设计时， <code>begin_cpu_access / end_cpu_access</code> 使用如下流式 DMA 接口来实现 Cache 同步：</p>
<ul>
<li>dma_sync_single_for_cpu() / dma_sync_single_for_device()</li>
<li>dma_sync_sg_for_cpu() / dma_sync_sg_for_device()</li>
</ul>
<p>CPU 访问内存之前，通过调用 <code>dma_sync_&#123;single,sg&#125;_for_cpu()</code> 来 <code>Invalidate Cache</code>，<br>这样 CPU 在后续访问时才能重新从 DDR 上加载最新的数据到 Cache 上。</p>
<p>CPU 访问内存结束之后，通过调用 <code>dma_sync_&#123;single,sg&#125;_for_device()</code> 来 <code>Flush Cache</code>，将 Cache 中的数据全部回写到 DDR 上，<br>这样后续 DMA 才能访问到正确的有效数据。</p>
<h2 id="User-API"><a href="#User-API" class="headerlink" title="User API"></a>User API</h2><p>考虑到 mmap() 操作，dma-buf 也为我们提供了 Userspace 的同步接口，通过 <code>DMA_BUF_IOCTL_SYNC ioctl()</code> 来实现。<br>该 cmd 需要一个 <code>struct dma_buf_sync</code> 参数，用于表明当前是 begin 还是 end 操作，是 read 还是 write 操作。</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul>
<li>只有在 DMA map/unmap 期间 CPU 又要访问内存的时候，才有必要使用 begin / end 操作；</li>
<li>{ begin,end }_cpu_access 实际是 dma_sync()* 接口的封装，目的是要 invalidate 或 flush cache；</li>
<li>Usespace 通过 DMA_BUF_IOCTL_SYNC 来触发 begin / end 操作；</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/12/Linux%E9%A9%B1%E5%8A%A8-container-of/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="huahui">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huahui">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/12/Linux%E9%A9%B1%E5%8A%A8-container-of/" class="post-title-link" itemprop="url">Container_of</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-02-12 21:12:34" itemprop="dateCreated datePublished" datetime="2022-02-12T21:12:34+08:00">2022-02-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-02-13 15:08:03" itemprop="dateModified" datetime="2022-02-13T15:08:03+08:00">2022-02-13</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="container-of-宏"><a href="#container-of-宏" class="headerlink" title="container_of 宏"></a>container_of 宏</h1><p>Linux 内核第一宏。主要作用：</p>
<blockquote>
<p>根据结构体某一成员的地址，获取这个结构体的首地址。</p>
</blockquote>
<p>主要原理：</p>
<blockquote>
<p>用结构体成员的地址，减去该成员在结构体内的偏移，即可得到该结构体的首地址。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * container_of - cast a member of a structure out to the containing structure</span></span><br><span class="line"><span class="comment"> * @ptr:	the pointer to the member.</span></span><br><span class="line"><span class="comment"> * @type:	the type of the container struct this is embedded in.</span></span><br><span class="line"><span class="comment"> * @member:	the name of the member within the struct.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (&#123;			\</span></span><br><span class="line"><span class="meta">	const typeof(((type *)0)-&gt;member) * __mptr = (ptr);	\</span></span><br><span class="line"><span class="meta">	(type *)((char *)__mptr - offsetof(type, member)); &#125;)</span></span><br></pre></td></tr></table></figure>

<p>container_of 宏三个参数：</p>
<ul>
<li>type: 结构体类型</li>
<li>member: 结构体内的成员</li>
<li>ptr: 结构体内成员member的地址</li>
</ul>
<h2 id="container-of-宏实现分析"><a href="#container-of-宏实现分析" class="headerlink" title="container_of 宏实现分析"></a>container_of 宏实现分析</h2><h3 id="offsetof-宏"><a href="#offsetof-宏" class="headerlink" title="offsetof 宏"></a>offsetof 宏</h3><blockquote>
<p>其功能是获得成员MEMBER在TYPE结构中的偏移量</p>
</blockquote>
<p>结构体作为一个复合类型数据，里面可包含多个变量。当我们定义一个结构体时，编译器要为其在内<br>存中分配空间。根据每个成员的数据类型和字节对齐方式，编译器会按照结构体中各个成员的顺序，在<br>内存中分配一片<strong>连续</strong>的空间来存储他们。</p>
<p>一个结构体数据类型，在同一编译环境下，各个成员相对于结构体首地址的偏移是固定不变的。<br><strong>当结构体的首地址为0时，结构体中各个成员的地址在数值上等同于结构体各成员相对于结构体首地址的偏移</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> math;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;age = %p\n&quot;</span>, &amp;((struct student*)<span class="number">0</span>)-&gt;age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;age = %p\n&quot;</span>, &amp;((struct student*)<span class="number">0</span>)-&gt;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;age = %p\n&quot;</span>, &amp;((struct student*)<span class="number">0</span>)-&gt;math);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line">在上面程序中，将数字<span class="number">0</span>通过强制类型转换，转换为一个指向结构体类型student的常量指针</span><br><span class="line">然后分别打印这个变量指针指向的各个成员地址。其运行结果如下：</span><br><span class="line">```c</span><br><span class="line">&amp;age = <span class="number">00000000</span></span><br><span class="line">&amp;num = <span class="number">00000004</span></span><br><span class="line">&amp;math = <span class="number">00000008</span></span><br></pre></td></tr></table></figure>

<p>因为常量指针的值为0，即可以看作结构体首地址为0，<br><strong>所以结构体每个成员变量的地址即该成员相对于结构体首地址的偏移</strong>。<br>这正是<code>offsetof</code>宏的功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span><br></pre></td></tr></table></figure>
<p>根据运算符优先级分析：</p>
<ul>
<li><code>(TYPE *)0</code>: 将0地址强制转化为一个指向TYPE类型的结构体常量指针</li>
<li><code>(TYPE *)0)-&gt;MEMBER</code>: 通过常量指针，访问成员MEMBER</li>
<li><code>&amp;((TYPE *)0)-&gt;MEMBER</code>: 获取MEMBER成员的地址，地址值即为MEMBER成员在TYPE结构中的偏移量</li>
<li><code>(size_t) &amp;((TYPE *)0)-&gt;MEMBER</code>: 将地址值强制转化为size_t类型的整形数</li>
</ul>
<h3 id="const-typeof-type-0-gt-member-mptr-ptr"><a href="#const-typeof-type-0-gt-member-mptr-ptr" class="headerlink" title="const typeof(((type *)0)-&gt;member) * __mptr = (ptr);"></a>const typeof(((type *)0)-&gt;member) * __mptr = (ptr);</h3><p>结构体中的成员数据可以是任意数据类型，为了让这个宏兼容各种数据类型，定义了一个临时指针变量<code>__mptr</code>,用来存储结构体成员MEMBER的地址，即存储宏中参数<code>ptr</code>的值。</p>
<p>必须保证<code>__mptr</code>和<code>ptr</code>的指针类型一样，因此使用<code>typeof</code>关键字，用来获取结构体成员MEMBER的数据类型。</p>
<blockquote>
<p>typeof 是 GNU C 新增的一个关键字，用来获取数据类型。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/12/Linux%E9%A9%B1%E5%8A%A8-linux-list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="huahui">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huahui">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/12/Linux%E9%A9%B1%E5%8A%A8-linux-list/" class="post-title-link" itemprop="url">List</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-02-12 20:59:11" itemprop="dateCreated datePublished" datetime="2022-02-12T20:59:11+08:00">2022-02-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-02-13 15:39:28" itemprop="dateModified" datetime="2022-02-13T15:39:28+08:00">2022-02-13</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux%E9%A9%B1%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">Linux驱动</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>内核链表的操作常用的二个宏<code>list_for_each_entry</code>和<code>list_for_each_entry_safe</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_for_each_entry	-	iterate over list of given type</span></span><br><span class="line"><span class="comment"> * @pos:	the type * to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @head:	the head for your list.</span></span><br><span class="line"><span class="comment"> * @member:	the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry(pos, head, member)				\</span></span><br><span class="line"><span class="meta">	for (pos = list_first_entry(head, typeof(*pos), member);	\</span></span><br><span class="line"><span class="meta">	     !list_entry_is_head(pos, head, member);			\</span></span><br><span class="line"><span class="meta">	     pos = list_next_entry(pos, member))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry</span></span><br><span class="line"><span class="comment"> * @pos:	the type * to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @n:		another type * to use as temporary storage</span></span><br><span class="line"><span class="comment"> * @head:	the head for your list.</span></span><br><span class="line"><span class="comment"> * @member:	the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_safe(pos, n, head, member)			\</span></span><br><span class="line"><span class="meta">	for (pos = list_first_entry(head, typeof(*pos), member),	\</span></span><br><span class="line"><span class="meta">		n = list_next_entry(pos, member);			\</span></span><br><span class="line"><span class="meta">	     !list_entry_is_head(pos, head, member); 			\</span></span><br><span class="line"><span class="meta">	     pos = n, n = list_next_entry(n, member))</span></span><br></pre></td></tr></table></figure>

<p><code>list_for_each_entry</code>宏是一个for循环语句，for循环的第一个参数就是让(head)-&gt;next指向member成员所在数据结构的指针，也就是将pos初始化为链表头指向的第一个实体链表成员，for的第三句话通过pos-&gt;member.next指针遍历整个实体链表，当pos-&gt;member.next再次指向我们的链表头的时候跳出for循环。整个过程没有对链表头进行遍历（不需要被遍历），所以使用list_for_each_entry遍历链表必须从链表头开始。 因此可以看出，list_for_each_entry的功能就是遍历以head为链表头的实体链表，对实体链表中的数据结构进行处理；</p>
<p><code>list_for_each_entry_safe</code>用指针n对链表的下一个数据结构进行了临时存储，所以如果在遍历链表的时候需要做删除链表中的当前项操作时，用list_for_each_entry_safe可以安全的删除，而不会影响接下来的遍历过程（用n指针可以继续完成接下来的遍历， 而list_for_each_entry则无法继续遍历，删除后会导致无法继续遍历）。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/12/git-git-error/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="huahui">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huahui">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/12/git-git-error/" class="post-title-link" itemprop="url">Git Error</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-02-12 20:52:06 / Modified: 20:54:46" itemprop="dateCreated datePublished" datetime="2022-02-12T20:52:06+08:00">2022-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/git/" itemprop="url" rel="index"><span itemprop="name">git</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="“error-invalid-path”"><a href="#“error-invalid-path”" class="headerlink" title="“error: invalid path”"></a>“error: invalid path”</h1><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>The Git cloning of repository succeeds on a Linux client but fails on a Windows client with an “invalid path” error.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>Depending on the filename, configuring Git to ignore NTFS naming may workaround the issue.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.protectNTFS false</span><br></pre></td></tr></table></figure>

<p>Turning off protectNTFS will stop Git from complaining about files that have a base name that is reserved but will not prevent an error if the filename is one of the reserved names.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/12/git-git-reset/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="huahui">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Huahui">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/12/git-git-reset/" class="post-title-link" itemprop="url">Git Reset</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-12-12 20:21:57 / Modified: 20:54:18" itemprop="dateCreated datePublished" datetime="2021-12-12T20:21:57+08:00">2021-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/git/" itemprop="url" rel="index"><span itemprop="name">git</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h1><p>首先解析以下这三个相关的状态和概念：</p>
<ol>
<li><p>HEAD：可以描述为当前分支最后一个提交。即本地的信息中的当前版本。</p>
</li>
<li><p>Index：在工作副本修改之后执行过git add操作的版本文件，可以commit了的。</p>
</li>
<li><p>Working Copy：工作副本是你正在修改，但是没有执行任何git操作的文件。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码修改，还没做任何操作的时候就是 Working Copy，</p>
<p>git add * 操作之后就是Index，</p>
<p>git commit 之后就是HEAD。如果代码修改了之后进行git add 操作，然后git commit，那么所有三者(HEAD,INDEX(STAGING),WORKING COPY)都是相同的状态，内容相同。</p>
<h1 id="–soft"><a href="#–soft" class="headerlink" title="–soft"></a>–soft</h1><p>–soft（更改HEAD）（恢复git commit的操作）</p>
<p>软重置。<strong>仅改变当前head指针</strong></p>
<p>–soft参数，Git只是单纯的把本地HEAD更改到你指定的版本，仅HEAD的定义发生了变化。</p>
<p>Working Copy 和Index的修改得以保留。</p>
<p>因为只回退了commit的信息。如果还要提交，可直接commit即可。</p>
<h1 id="–hard（更改三者）"><a href="#–hard（更改三者）" class="headerlink" title="–hard（更改三者）"></a>–hard（更改三者）</h1><p>–hard 参数将当前 HEAD, INDEX(STAGING), WORKING COPY 全部改变。</p>
<p>不仅工作区修改的代码会还原，暂存区的信息也会丢弃。</p>
<h1 id="–mixed-default）"><a href="#–mixed-default）" class="headerlink" title="–mixed(default）"></a>–mixed(default）</h1><p>恢复git add的操作，包含恢复git commit的操作</p>
<p>–mixed是reset的默认参数，不指定任何参数时默认使用。</p>
<p>移动head指针，改变暂存区内容，但<strong>不会改变工作区</strong></p>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p><code>git reset</code>用于在进行<code>git add</code>和<code>git commit</code>操作后，但还未进行<code>git push</code>操作时进行版本管理。</p>
<p>1、soft： 重置git commit</p>
<p>2、mixed： 重置git commit 和 git add</p>
<p>3、hard： 重置git commit 和 git add 和工作副本的修改。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">huahui</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
